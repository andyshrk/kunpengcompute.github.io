<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kunpeng Compute Team Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-12T05:04:20.392Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>鲲鹏计算开源生态团队</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web开源服务之ARM64现状</title>
    <link href="http://yoursite.com/2020/04/10/web-kai-yuan-fu-wu-zhi-arm64-xian-zhuang/"/>
    <id>http://yoursite.com/2020/04/10/web-kai-yuan-fu-wu-zhi-arm64-xian-zhuang/</id>
    <published>2020-04-10T03:03:00.000Z</published>
    <updated>2020-04-12T05:04:20.392Z</updated>
    
    <content type="html"><![CDATA[<p>作者: <a href="https://github.com/wangxiyuan">王玺源</a></p><p>社区核心参与者：<a href="https://github.com/martin-g">Martin Grigorov</a>、<a href="https://www.linkedin.com/in/mikerumph/">Michael Rumph</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>开源界中Web服务众多,但其中很多软件对ARM64的支持并不理想。或是没有官方CI测试保证代码质量，或是在ARM64上的性能明显差于X86_64，甚至有的服务根本无法在ARM上运行。为了完善Web领域的ARM64生态，我们参与了主流的几个开源社区，旨在推动Web on ARM64。以下是我们近期的一些进展，以供大家参考。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们目前参与了主流的共9个Web相关项目。如下所示</p><table><thead><tr><th>项目</th><th>主要语言</th></tr></thead><tbody><tr><td>Apache Httpd Server</td><td>C</td></tr><tr><td>Apache Tomcat</td><td>Java</td></tr><tr><td>Memcached</td><td>C</td></tr><tr><td>Nginx</td><td>C</td></tr><tr><td>Lighttpd</td><td>C</td></tr><tr><td>JBoss/WildFly</td><td>Java</td></tr><tr><td>HAProxy</td><td>C</td></tr><tr><td>Squid</td><td>C++</td></tr><tr><td>Varnish Cache</td><td>C</td></tr></tbody></table><p>针对这些项目，我们按照以下三个方面循序渐进的推动中:</p><ol><li>能不能在ARM上运行</li><li>如何稳定在ARM上运行</li><li>怎么更好的在ARM上运行</li></ol><h1 id="能不能在ARM上运行"><a href="#能不能在ARM上运行" class="headerlink" title="能不能在ARM上运行"></a>能不能在ARM上运行</h1><p>我们可以看到这9大项目主要由Java和C/C++编写。</p><p>首先，像Python、Java这种自带runtime的语言天生就是跨平台的。这样的项目在ARM64平台上至少可以保证程序的可运行。</p><p>而C/C++项目则需要先编译成ARM64平台的目标可执行文件。这样的项目则需要先进行编译测试。</p><p>经过我们的测试，这9个Web项目都可以在ARM64上成功编译并运行。</p><h1 id="如何稳定在ARM上运行"><a href="#如何稳定在ARM上运行" class="headerlink" title="如何稳定在ARM上运行"></a>如何稳定在ARM上运行</h1><p>所谓稳定，包含两个方面：</p><ol><li>软件在ARM64上是否和在X86_64上行为一致？</li><li>随着代码更新迭代，软件在ARM64上是否持续可用？</li></ol><h2 id="行为一致"><a href="#行为一致" class="headerlink" title="行为一致"></a>行为一致</h2><p>我们常遇到两类行为一致的问题：</p><ol><li>同样的代码，不同的结果</li><li>同样的功能，不同的支持</li></ol><p>很遗憾，由于架构不同、底层实现不同等原因，很多软件的某些行为在X86_64和ARM64上的行为并不一致。</p><p>例如，之前的<a href="https://kunpengcompute.github.io/2020/04/08/arm-you-hua-he-java-math-ku-you-guan-de-na-xie-keng/">文章</a>提到的Java中Math计算结果的差异。</p><p>又或者某些功能依赖独有的平台特性或者特殊的第三方库，导致在X86_64上可以运行的功能，在ARM64上却执行失败。</p><p>例如我们发现WildFly官方发布的源码包中缺少了个别ARM64平台的<code>.so</code>文件，这就导致个别调用<code>.so</code>的功能不可用。</p><p>针对这种问题，我们需要打开代码逐个分析、逐个修复。保证所有测试在ARM64上全部通过。</p><h2 id="持续可用"><a href="#持续可用" class="headerlink" title="持续可用"></a>持续可用</h2><p>CI/CD是保证软件持续可用的重要方法。主流软件的CI系统都有X86_64平台的测试。而ARM64平台的少之又少。</p><p>针对这个问题，我们推动了这9个项目的ARM CI支持。除Lighttpd还在推动中以外，其他8个项目目前都已支持了ARM CI。甚至其中4个项目已经官方声明了ARM64的支持（详见附录）。</p><p>其中Httpd、Tomcat、Memcached、HAProxy和Varnish Cache通过Travis CI支持了ARM64测试。Nginx使用内部CI，对外不可见。Squid使用自己的树莓派。而JBOSS使用了我们捐献的基于Kunpeng 920的ARM虚拟机。同时我们也计划捐献同样的测试机到Lighttpd社区中。</p><p>随着ARM CI的落地，我们将持续保证ARM CI的稳定。我们相信在不久的将来，这9大核心Web项目都会官方声明ARM64的支持，并满足用户在ARM64上稳定、高效使用Web服务的需求。</p><h1 id="怎么更好的在ARM上运行"><a href="#怎么更好的在ARM上运行" class="headerlink" title="怎么更好的在ARM上运行"></a>怎么更好的在ARM上运行</h1><p>我们不仅希望软件在ARM64上能用，还在不断探索如何让软件在ARM64上用的好。其中<strong>性能优化</strong>是重中之重，也是我们未来一段时间的主要投入点。</p><p>例如，有些软件只实现了X86_64的汇编实现，但缺少ARM64的汇编代码。</p><p>又或者有些在X86_64上纯软实现的功能，可以在ARM64上通过下沉至硬编码的方式提高性能。</p><p>甚至还可以考虑如何最大化利用ARM64的多核优势，或规避ARM64的锁劣势等等。</p><p>关于性能优化的内容，我们将在以后的文章中针对不同的软件一一细说。敬请期待。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>最后附上我们参与Web社区的总览表格及相关链接，感兴趣的同学可以进一步详读，有任何问题，欢迎留言。</p><table><thead><tr><th></th><th>Official arm64 CI</th><th>CI tool</th><th>Package in Downloads</th><th>Official ARM support</th></tr></thead><tbody><tr><td><a href="https://tomcat.apache.org/">Apache Tomcat</a></td><td><a href="https://github.com/apache/tomcat/commit/f386fbb4abaa3fe8f3b3df1da7d14f756c729e2e">YES</a></td><td><a href="https://github.com/apache/tomcat/blob/master/.travis.yml">TravisCI</a></td><td><a href="https://tomcat.apache.org/download-90.cgi">Binary</a></td><td>WIP(work in progress)</td></tr><tr><td><a href="https://memcached.org/">Memcached</a></td><td><a href="https://github.com/memcached/memcached/pull/593">YES</a></td><td>1. <a href="http://build.memcached.org:8010/">BuildBot</a> 2. <a href="https://github.com/memcached/memcached/blob/master/.travis.yml">TravisCI</a></td><td><a href="https://memcached.org/downloads">Source Code</a></td><td><a href="https://github.com/memcached/memcached/wiki/Hardware">YES</a></td></tr><tr><td><a href="https://httpd.apache.org/">Apache httpd</a></td><td><a href="https://markmail.org/message/ajm3eouaqfhm22ox">YES</a></td><td><a href="https://github.com/apache/httpd/blob/trunk/.travis.yml">TravisCI</a></td><td><a href="http://httpd.apache.org/download.cgi">Source Code</a></td><td><a href="https://github.com/apache/httpd/blob/2.4.x/CHANGES#L17-L20">YES</a></td></tr><tr><td><a href="https://nginx.org/">NGINX</a></td><td><a href="https://mailman.nginx.org/pipermail/nginx-devel/2020-January/012943.html">YES</a></td><td>Internal</td><td>Only for <a href="https://nginx.org/en/linux_packages.html">Ubuntu</a> LTSs</td><td><a href="https://nginx.org/en/linux_packages.html#Ubuntu">YES</a></td></tr><tr><td><a href="https://www.lighttpd.net/">Lighttpd</a></td><td>NO</td><td><a href="https://ci.lighttpd.net/view/lighttpd1.4/job/lighttpd1.4/">Jenkins</a></td><td><a href="https://www.lighttpd.net/download/">Source Code</a></td><td>NO</td></tr><tr><td><a href="https://www.wildfly.org/">JBoss/Wildfly</a></td><td><a href="https://ci.wildfly.org/viewType.html?buildTypeId=WF_MasterLinuxArm64OpenJ911">YES</a></td><td><a href="https://ci.wildfly.org/">TeamCity</a></td><td><a href="https://wildfly.org/downloads/">Source Code</a></td><td>NO</td></tr><tr><td><a href="https://www.haproxy.org/">HAProxy</a></td><td><a href="https://github.com/haproxy/haproxy/commit/9bf2a1be89a6eaddb00f07b9d069a9a16c24c037">YES</a></td><td>1. <a href="https://cirrus-ci.com/github/haproxy/haproxy">CirrusCI</a> <br> 2. <a href="https://github.com/haproxy/haproxy/blob/master/.travis.yml">TravisCI</a></td><td><a href="http://www.haproxy.org/">Source Code</a></td><td><a href="https://www.haproxy.org/#plat">YES</a></td></tr><tr><td><a href="http://www.squid-cache.org/">Squid</a></td><td><a href="http://build.squid-cache.org/computer/arm64-rpi/">YES</a></td><td><a href="http://build.squid-cache.org/">Jenkins</a></td><td><a href="http://squid-cache.org/Versions/">Source Code</a></td><td>NO</td></tr><tr><td><a href="https://github.com/varnishcache/varnish-cache/">Varnish Cache</a></td><td><a href="https://github.com/varnishcache/varnish-cache/pull/3195">YES</a></td><td><a href="https://github.com/varnishcache/varnish-cache/blob/master/.travis.yml">Travis</a></td><td>1. <a href="https://varnish-cache.org/releases/index.html">Source Code</a> <br> 2. <a href="https://packagecloud.io/varnishcache">Package</a></td><td>NO</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: &lt;a href=&quot;https://github.com/wangxiyuan&quot;&gt;王玺源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区核心参与者：&lt;a href=&quot;https://github.com/martin-g&quot;&gt;Martin Grigorov&lt;/a&gt;、&lt;a href=&quot;https://www.linkedin.com/in/mikerumph/&quot;&gt;Michael Rumph&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;开源界中Web服务众多,但其中很多软件对ARM64的支持并不理想。或是没有官方CI测试保证代码质量，或是在ARM64上的性能明显差于X86_64，甚至有的服务根本无法在ARM上运行。为了完善Web领域的ARM64生态，我们参与了主流的几个开源社区，旨在推动Web on ARM64。以下是我们近期的一些进展，以供大家参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MySQL on x86 vs ARM</title>
    <link href="http://yoursite.com/2020/04/08/mysql-on-x86-vs-arm/"/>
    <id>http://yoursite.com/2020/04/08/mysql-on-x86-vs-arm/</id>
    <published>2020-04-08T10:16:43.000Z</published>
    <updated>2020-04-12T05:04:20.392Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Krunal Bauskar</p><p>By and large this would be a topic of interest for most of us including me when I started to explore this space. Before we dwell into the numbers let’s first understand some basic differences between 2 architectures. Beyond being CISC and RISC let’s look at the important differences from MySQL perspective.</p><a id="more"></a><ul><li>Strong vs Weak memory model (weak memory model needs proper memory barrier while writing lock-free code).</li><li>Underlying hardware specific specialized instructions. For example: both now support crc32c hardware instructions but being low-level they are different ways to invoke them. For more differences checkout for x86-SSE/ARM-ACLE.</li><li>Cache Line differences. Most of the ARM processors tend to use bigger cache lines (128 bytes for all caches or a mix of 64/128 bytes).</li><li>Other sys-call level differences like: absence of PAUSE instructions with ARM and substitute instruction with very low latency failing to induce needed delay, sched_getcpu is costlier on ARM introducing challenges with use of lock-free construct, memory operations seems to show higher latency, etc…</li></ul><p>Community has contributed multiple patches around this space (Topic for another blog). Since MySQL just started supporting MySQL on ARM there are  few optimizations but most of the work is yet to be done.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a><span style="color:#4885ed">Performance</span></h2><p>Now let’s look at the most important aspect: Performance</p><p>We tested the performance of MySQL (current release 8.0.19) on x86 and ARM. Details of the test and machine are given below.</p><h3 id="Test-Setup"><a href="#Test-Setup" class="headerlink" title="Test Setup"></a><span style="color:#1aa260">Test Setup</span></h3><ul><li>24 vCPU/48 GB Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz for running MySQL on x86.</li><li>24 vCPU/48 GB ARM @ 2.60GHz for running MySQL on ARM</li><li>sysbench is running on a dedicated machine located in the same data-center.</li><li>sysbench steps:<ul><li>Load Tables. (Same seed db is reused for multiple runs so warmup is needed).</li><li>Checksum based warmup. Run checksum on all tables. For checksum, flow needs to fetch the rows in the buffer pool there-by causing it to warm up.</li><li>Query based warm up. Can skip but helpful if you are using adaptive hash indexes.</li><li>Execute TC (oltp-read-write/oltp-update-index/oltp-update-non-index/oltp-read-only/oltp-point-select)</li><li>Each TC is executed for N different scalability. Given 24 vCPU tried it for 1/2/4/8/16/32/128/256.</li><li>Before switching TC, an intermediate sleep is introduced to help flush changes from previous TC. This can’t ensure all changes are flushed but sleep of X secs ensures least impact on followup TC.</li><li>MySQL-Server Configuration:<ul><li>BP is large enough to accomodate complete data in-memory</li><li>For more details please check the <a href="https://github.com/mysqlonarm/benchmark-suites/blob/master/sysbench/conf/96tx1.5m_cpubound.cnf">following configuration details</a></li></ul></li></ul></li></ul><p></p><br> Details of running the scripts and automated test-script to invoke sysbench are also [available here](https://github.com/mysqlonarm/benchmark-suites)<h3 id="Run-specific-details"><a href="#Run-specific-details" class="headerlink" title="Run specific details:"></a><span style="color: #1aa260">Run specific details:</span></h3><ul><li>Table: 96-tables * 1.5 million (data-size= 34GB)</li><li>Buffer Pool: 36GB</li><li>Redo-Log: 4GB*2</li><li>TC-run-time: 300 secs</li><li>TC-warmup: 60 (sysbench –warmup-time)</li><li>workload-query-based warmup: 600</li><li>change-over-sleep: 180</li><li>checksum-based-warmup: enabled</li><li>data-storage: 300GB (support for 16500 IOPS (nullify effect of Burst IOPS)).</li></ul><p><font size="3"><em>Note: Frequency Scaling (FS). Given ARM is running @ 2.6 GHz vs x86 is running @ 3.0 GHz. Comparing them directly is not fair. In order to compensate for the frequency difference, graphs also add frequency-scaled tps/qps for ARM (ARM-fscaled simply extrapolate original ARM tps/qps number by (3/2.6) factor). In real life, the factor could be a bit on the higher side given increasing CPU frequency can affect contention graphs and wait cycles.</em></font></p><br><hr><h3 id="1-Point-Select"><a href="#1-Point-Select" class="headerlink" title="1. Point Select:"></a><span style="color: #de5246"><ins>1. Point Select:</ins></span></h3><img src="https://mysqlonarm.github.io/images/blog3/ARM-vs-x86-ps.png" width="100%"/><table><thead><tr><th>threads</th><th>ARM (qps)</th><th>x86 (qps)</th><th>ARM (qps - fscaled (FS))</th><th>% ARM-vs-x86</th><th>% ARM (FS)-vs-x86</th></tr></thead><tbody><tr><td>1</td><td>6696</td><td>6439</td><td>7726</td><td>4</td><td>20</td></tr><tr><td>2</td><td>12482</td><td>11774</td><td>14402</td><td>6</td><td>22</td></tr><tr><td>4</td><td>23881</td><td>21308</td><td>27555</td><td>12</td><td>29</td></tr><tr><td>8</td><td>45993</td><td>42110</td><td>53069</td><td>9</td><td>26</td></tr><tr><td>16</td><td>88517</td><td>81239</td><td>102135</td><td>9</td><td>26</td></tr><tr><td>32</td><td>142974</td><td>136724</td><td>164970</td><td>5</td><td>21</td></tr><tr><td>64</td><td>198839</td><td>212484</td><td>229430</td><td>-6</td><td>8</td></tr><tr><td>128</td><td>217778</td><td>241555</td><td>251282</td><td>-10</td><td>4</td></tr><tr><td>256</td><td>209797</td><td>224009</td><td>242073</td><td>-6</td><td>8</td></tr></tbody></table><h4 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis:"></a>Analysis:</h4><ul><li>ARM performs better than x86 for lower scalability but fails to scale at same rate with increasing scalability.</li><li>With frequency scaling applied ARM continues to beat x86 despite of the scalability issues.</li></ul><br><hr><h3 id="2-Read-Only"><a href="#2-Read-Only" class="headerlink" title="2. Read Only:"></a><span style="color: #de5246"><ins>2. Read Only:</ins></span></h3><img src="https://mysqlonarm.github.io/images/blog3/ARM-vs-x86-ro.png" width="100%"/><table><thead><tr><th>threads</th><th>ARM (qps)</th><th>x86 (qps)</th><th>ARM (qps - fscaled (FS))</th><th>% ARM-vs-x86</th><th>% ARM (FS)-vs-x86</th></tr></thead><tbody><tr><td>1</td><td>5222</td><td>5259</td><td>6025</td><td>-1</td><td>15</td></tr><tr><td>2</td><td>10333</td><td>10200</td><td>11923</td><td>1</td><td>17</td></tr><tr><td>4</td><td>19176</td><td>19349</td><td>22126</td><td>-1</td><td>14</td></tr><tr><td>8</td><td>36881</td><td>37035</td><td>42555</td><td>0</td><td>15</td></tr><tr><td>16</td><td>70337</td><td>67065</td><td>81158</td><td>5</td><td>21</td></tr><tr><td>32</td><td>109207</td><td>113210</td><td>126008</td><td>-4</td><td>11</td></tr><tr><td>64</td><td>139294</td><td>164148</td><td>160724</td><td>-15</td><td>-2</td></tr><tr><td>128</td><td>151382</td><td>175872</td><td>174672</td><td>-14</td><td>-1</td></tr><tr><td>256</td><td>149136</td><td>164382</td><td>172080</td><td>-9</td><td>5</td></tr></tbody></table><h4 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis:"></a>Analysis:</h4><ul><li>ARM is almost on par with x86 for lower scalability but again fails to scale for higher scalability.</li><li>With frequency scaling applied ARM continues to beat x86 (in most cases).</li></ul><br><hr><h3 id="3-Read-Write"><a href="#3-Read-Write" class="headerlink" title="3. Read Write:"></a><span style="color: #de5246"><ins>3. Read Write:</ins></span></h3><img src="https://mysqlonarm.github.io/images/blog3/ARM-vs-x86-rw.png" width="100%"/><table><thead><tr><th>threads</th><th>ARM (tps)</th><th>x86 (tps)</th><th>ARM (tps - fscaled (FS))</th><th>% ARM-vs-x86</th><th>% ARM (FS)-vs-x86</th></tr></thead><tbody><tr><td>1</td><td>137</td><td>149</td><td>158</td><td>-8</td><td>6</td></tr><tr><td>2</td><td>251</td><td>273</td><td>290</td><td>-8</td><td>6</td></tr><tr><td>4</td><td>462</td><td>502</td><td>533</td><td>-8</td><td>6</td></tr><tr><td>8</td><td>852</td><td>920</td><td>983</td><td>-7</td><td>7</td></tr><tr><td>16</td><td>1539</td><td>1678</td><td>1776</td><td>-8</td><td>6</td></tr><tr><td>32</td><td>2556</td><td>2906</td><td>2949</td><td>-12</td><td>1</td></tr><tr><td>64</td><td>3770</td><td>5158</td><td>4350</td><td>-27</td><td>-16</td></tr><tr><td>128</td><td>5015</td><td>8131</td><td>5787</td><td>-38</td><td>-29</td></tr><tr><td>256</td><td>5676</td><td>8562</td><td>6549</td><td>-34</td><td>-24</td></tr></tbody></table><h4 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis:"></a>Analysis:</h4><ul><li>Pattern is different with read-write workload. ARM starts lagging. Frequency scaling helps ease this lag for lower scalability but increasing scalability continues to increase the gap.</li></ul><br><hr><h3 id="4-Update-Index"><a href="#4-Update-Index" class="headerlink" title="4. Update Index:"></a><span style="color: #de5246"><ins>4. Update Index:</ins></span></h3><img src="https://mysqlonarm.github.io/images/blog3/ARM-vs-x86-ui.png" width="100%"/><table><thead><tr><th>threads</th><th>ARM (tps)</th><th>x86 (tps)</th><th>ARM (tps - fscaled (FS))</th><th>% ARM-vs-x86</th><th>% ARM (FS)-vs-x86</th></tr></thead><tbody><tr><td>1</td><td>328</td><td>373</td><td>378</td><td>-12</td><td>1</td></tr><tr><td>2</td><td>623</td><td>768</td><td>719</td><td>-19</td><td>-6</td></tr><tr><td>4</td><td>1060</td><td>1148</td><td>1223</td><td>-8</td><td>7</td></tr><tr><td>8</td><td>1905</td><td>2028</td><td>2198</td><td>-6</td><td>8</td></tr><tr><td>16</td><td>3284</td><td>3590</td><td>3789</td><td>-9</td><td>6</td></tr><tr><td>32</td><td>5543</td><td>6275</td><td>6396</td><td>-12</td><td>2</td></tr><tr><td>64</td><td>9138</td><td>10381</td><td>10544</td><td>-12</td><td>2</td></tr><tr><td>128</td><td>13879</td><td>16868</td><td>16014</td><td>-18</td><td>-5</td></tr><tr><td>256</td><td>19954</td><td>25459</td><td>23024</td><td>-22</td><td>-10</td></tr></tbody></table><h4 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis:"></a>Analysis:</h4><ul><li>Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases).</li></ul><br><hr><h3 id="5-Update-Non-Index"><a href="#5-Update-Non-Index" class="headerlink" title="5. Update Non-Index:"></a><span style="color: #de5246"><ins>5. Update Non-Index:</ins></span></h3><img src="https://mysqlonarm.github.io/images/blog3/ARM-vs-x86-uni.png" width="100%"/><table><thead><tr><th>threads</th><th>ARM (tps)</th><th>x86 (tps)</th><th>ARM (tps - fscaled (FS))</th><th>% ARM-vs-x86</th><th>% ARM (FS)-vs-x86</th></tr></thead><tbody><tr><td>1</td><td>328</td><td>373</td><td>378</td><td>-12</td><td>1</td></tr><tr><td>2</td><td>588</td><td>686</td><td>678</td><td>-14</td><td>-1</td></tr><tr><td>4</td><td>1075</td><td>1118</td><td>1240</td><td>-4</td><td>11</td></tr><tr><td>8</td><td>1941</td><td>2043</td><td>2240</td><td>-5</td><td>10</td></tr><tr><td>16</td><td>3367</td><td>3662</td><td>3885</td><td>-8</td><td>6</td></tr><tr><td>32</td><td>5681</td><td>6438</td><td>6555</td><td>-12</td><td>2</td></tr><tr><td>64</td><td>9328</td><td>10631</td><td>10763</td><td>-12</td><td>1</td></tr><tr><td>128</td><td>14158</td><td>17245</td><td>16336</td><td>-18</td><td>-5</td></tr><tr><td>256</td><td>20377</td><td>26367</td><td>23512</td><td>-23</td><td>-11</td></tr></tbody></table><h4 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis:"></a>Analysis:</h4><ul><li>Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases).</li></ul><br><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><span style="color:#4885ed">Conclusion</span></h2><p>There are some important observations we can make:</p><ul><li>For read only workload MySQL on ARM continues to perform on-par with MySQL on x86. </li><li>For write involving workload MySQL on ARM starts lagging a bit but if we consider frequency scaling things start getting  better.</li><li>Frequency scaling is not a real life parameter so we should consider the price-per-performance ratio. This could be a topic in itself but just a quick fact: ARM instance is 66% cheaper than x86 (24U48G same one we used).</li><li>There is a pattern that we can observe. ARM workloads are very well scalable till it hits the CPU limits. With increasing scalability, contention increases and ARM starts lagging. This is expected since mutexes/contention hot-spots were all tuned for x86 (for example: spin-lock). But now that MySQL officially supports ARM and the growing ARM community and interest, it would be tuned for ARM too.</li></ul><p>To summarize, MySQL on ARM is a worth exploring option from a cost and performance perspective.</p><br><em>If you have more questions/queries do let me know. Will try to answer them.</em>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: Krunal Bauskar&lt;/p&gt;
&lt;p&gt;By and large this would be a topic of interest for most of us including me when I started to explore this space. Before we dwell into the numbers let’s first understand some basic differences between 2 architectures. Beyond being CISC and RISC let’s look at the important differences from MySQL perspective.&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ARM优化和Java Math库有关的那些坑</title>
    <link href="http://yoursite.com/2020/04/08/arm-you-hua-he-java-math-ku-you-guan-de-na-xie-keng/"/>
    <id>http://yoursite.com/2020/04/08/arm-you-hua-he-java-math-ku-you-guan-de-na-xie-keng/</id>
    <published>2020-04-08T03:44:29.000Z</published>
    <updated>2020-04-12T05:04:20.392Z</updated>
    
    <content type="html"><![CDATA[<p>作者：姜逸坤</p><h2 id="1-起初"><a href="#1-起初" class="headerlink" title="1. 起初"></a>1. 起初</h2><p>最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Math.log(3): "</span> + Math.log(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"StrictMath.log(3): "</span> + StrictMath.log(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们发现，在x86下，Math的结果为<code>1.0986122886681098</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> on x86</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Math.log(3): 1.0986122886681098</span><br><span class="line">StrictMath.log(3): 1.0986122886681096</span><br></pre></td></tr></table></figure><p>而aarch64的结果为<code>1.0986122886681096</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> on aarch64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Math.log(3): 1.0986122886681096</span><br><span class="line">StrictMath.log(3): 1.0986122886681096</span><br></pre></td></tr></table></figure><p>而在Java 8的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html">官方文档</a>中，对此有明确说明：</p><blockquote><p>Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required.</p></blockquote><p>因此，结论是：<strong>Math的结果有可能是不精确的，如果结果对精度有苛求，那么请使用StrictMath</strong>。</p><p>在此，我们留下2个疑问：</p><ol><li>为什么说Math的实现不是<code>the bit-for-bit same results</code>？</li><li>Math是怎么实现在各个架构下<code>better-performing implementations</code>的？</li></ol><h2 id="2-深度探索一下Math的实现"><a href="#2-深度探索一下Math的实现" class="headerlink" title="2. 深度探索一下Math的实现"></a>2. 深度探索一下Math的实现</h2><p>为了能够更清晰的看到StrictMath的实现，我们深入的看了下JDK的实现。</p><h3 id="2-1-Math和StrictMath的基本实现"><a href="#2-1-Math和StrictMath的基本实现" class="headerlink" title="2.1 Math和StrictMath的基本实现"></a>2.1 Math和StrictMath的基本实现</h3><p>我们从Math.log和StrictMath.log的实现为例，进行深入学习：</p><ol><li><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/classes/java/lang/Math.java#l293">Math.log的代码</a>表面上很简单，就是直接调用StrictMath.log。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StrictMath.log(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/classes/java/lang/StrictMath.java#l231">StrictMath的代码</a>，会调用<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/StrictMath.c#l76">StrictMath.c</a>中的方法，最终会调用fdlibm的<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/fdlibm/src/e_log.c">e_log.c</a>的实现。</li></ol><p>总体的实现和下图类似：<br><img src="https://user-images.githubusercontent.com/1736354/78893132-569ff880-7a9d-11ea-85dc-4652c9bf85f8.png" alt="image"></p><p>对于StrictMath来说，没有什么黑科技，最终的实现就是e_log.c的ieee754标准实现，是通过C语言实现的，所以在各个平台的表现是一样的，整个流程如图中蓝色部分。感兴趣的同学可以看<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/fdlibm/src/e_log.c">e_log.c</a>的源码实现即可。</p><h3 id="2-2-Math的黑科技"><a href="#2-2-Math的黑科技" class="headerlink" title="2.2 Math的黑科技"></a>2.2 Math的黑科技</h3><p>回到我们最初的起点，再加上一个问题：</p><ol><li>为什么说Math的实现不是<code>the bit-for-bit same results</code>？</li><li>Math是怎么实现在各个架构下<code>better-performing implementations</code>的？</li><li>既然Math的实现，也是直接调用StrictMath，为什么结果确不一样呢？</li></ol><p>原来，JVM为了让各个arch的CPU能够充分的发挥自己CPU的优势，会根据架构不同，会通过Hotspot intrinsics替换掉Math函数的实现，我们可以从代码<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/dae2d83e0ec2/src/share/vm/classfile/vmSymbols.hpp#l598">vmSymbols.hpp</a>看到，Math的很多实现都被替换掉了。log的替换类似于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_intrinsic(_dlog, java_lang_Math, log_name, double_double_signature, F_S)</span><br></pre></td></tr></table></figure><p>最终，Math的调用为下图红色部分：</p><p><img src="https://user-images.githubusercontent.com/1736354/78893234-8f3fd200-7a9d-11ea-903a-311c8c3cc836.png" alt="image"></p><p>log的实现:</p><ul><li>在x86下，最终其实调用的是<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/dae2d83e0ec2/src/cpu/x86/vm/assembler_x86.cpp#l4140">assembler_x86.cpp</a>中的<code>flog</code>实现:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assembler::flog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fldln2();</span><br><span class="line">  fxch();</span><br><span class="line">  fyl2x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>而在aarch64下，我们可以从<a href="http://hg.openjdk.java.net/jdk/jdk/file/e53ec3b362f4/src/hotspot/cpu/">src/hotspot/cpu/</a>目录下看到，aarch64并未实现优化版本。因此，实际aarch64调用的就是标准的StrictMath。</li></ul><p>正因如此，x86汇编的计算结果的差异导致了x86和aarch64结果在Math.log差异。</p><p>当然，aarch64也在JDK 11中，对部分的Math接口做了加速实现，有兴趣可以看看<a href="https://bugs.openjdk.java.net/browse/JDK-8189104">JEP 315: Improve Aarch64 Intrinsics</a>的实现。</p><h2 id="3-toRadians的小插曲"><a href="#3-toRadians的小插曲" class="headerlink" title="3. toRadians的小插曲"></a>3. toRadians的小插曲</h2><p>在ARM优化过程中，有的是因为Math库和StrictMath不同的实现造成结果不同，所以我们如果对精度要求非常高，直接切到StrictMath即可。</p><p>但有的函数，由于在Java大版本升级的过程中，出现了一些实现的差异，先看一个简单的Java程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Math.toRadians(0.33): "</span> + Math.toRadians(<span class="number">0.33</span>));</span><br><span class="line">System.out.println(<span class="string">"StrictMath.toRadians(0.33): "</span> + StrictMath.toRadians(<span class="number">0.33</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别看看在Java11和Java8的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-11-openjdk-amd64&#x2F;bin&#x2F;java Hello</span><br><span class="line">Math.toRadians(0.33): 0.005759586531581287</span><br><span class="line">StrictMath.toRadians(0.33): 0.005759586531581287</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-amd64&#x2F;bin&#x2F;java Hello</span><br><span class="line">Math.toRadians(0.33): 0.005759586531581288</span><br><span class="line">StrictMath.toRadians(0.33): 0.005759586531581288</span><br></pre></td></tr></table></figure><p>最后一位很奇怪的差了1，我们继续深入进去看到toRadians的实现：</p><ul><li><a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Math.java#l236">Java8的实现</a>为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> angrad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> angrad * <span class="number">180.0</span> / PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/Math.java#l253">Java11的实现</a>为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DEGREES_TO_RADIANS = <span class="number">0.017453292519943295</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> angdeg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> angdeg * DEGREES_TO_RADIANS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>原来在Java11的实现中，为了优化性能，将<code>* 180.0 / PI</code>提前算好了，这样每次只用乘以乘数即可，从而化简了计算。这也最终导致了，Java8和Java11在精度上有一些差别。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>Math在各个arch下的实现不同，精度也不同，如果对精度要求很高，可以使用StrictMath。</li><li>Java不同版本的优化，也有可能导致Math库的精度不同</li><li>Math库在实现时，利用intrinsics机制，把各个arch下Math的实现换掉了，从而充分的发挥各个CPU自身的优势。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：姜逸坤&lt;/p&gt;
&lt;h2 id=&quot;1-起初&quot;&gt;&lt;a href=&quot;#1-起初&quot; class=&quot;headerlink&quot; title=&quot;1. 起初&quot;&gt;&lt;/a&gt;1. 起初&lt;/h2&gt;&lt;p&gt;最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Hello&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Math.log(3): &quot;&lt;/span&gt; + Math.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;StrictMath.log(3): &quot;&lt;/span&gt; + StrictMath.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="基础库" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E5%BA%93/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="基础库" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ARM CPU Vendor 及 Part ID 映射关系（持续更新）</title>
    <link href="http://yoursite.com/2020/04/03/arm-cpu-vendor-ji-part-id-ying-she-guan-xi-chi-xu-geng-xin/"/>
    <id>http://yoursite.com/2020/04/03/arm-cpu-vendor-ji-part-id-ying-she-guan-xi-chi-xu-geng-xin/</id>
    <published>2020-04-03T04:51:40.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>作者：郑振宇</p><p>根据<a href="https://developer.arm.com/docs/ddi0595/b/aarch64-system-registers/midr_el1">ARM CPU官方技术手册</a>，ARM CPU的CPU型号、Vendor、版本等信息存于<code>MIDR_EL1</code>寄存器中:<br><img width="492" alt="MIDR" src="https://user-images.githubusercontent.com/10849016/78315745-79f41080-7590-11ea-97cd-787ed68d6933.PNG"><br>其中从低至高第0-3 bit表示<code>revision</code>，代表固件版本的小版本号，如r1p3中的p3；<br>第4-15 bit表示<code>part number(id)</code>，代表这款CPU在所在<code>vendor</code>产品中定义的产品代码，如在<code>HiSilicon</code>产品中，<code>part_id=0xd01</code>代表<code>Kunpeng-920</code>芯片；<br>第16-19 bit表示<code>architecture</code>，即架构版本，<code>0x8</code>即ARMv8；<br>第20-23 bit表示<code>variant</code>，即固件版本的大版本号，如r1p3中的r1；<br>第24-31 bit表示<code>implementer</code>，即<code>vendor id</code>，如<code>vendor_id=0x48</code>表示<code>HiSilicon</code>。</p><a id="more"></a><p>想要知道一款ARM CPU的具体型号，则需要首先解析<code>vendor_id(implementer)</code> 然后再在该Vendor的所有型号中匹配<code>part_id</code>，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系，以及主流厂商的主要型号映射关系：</p><h1 id="Vendor映射关系："><a href="#Vendor映射关系：" class="headerlink" title="Vendor映射关系："></a>Vendor映射关系：</h1><table><thead><tr><th>Vendor Name</th><th>Vendor ID</th></tr></thead><tbody><tr><td>ARM</td><td>0x41</td></tr><tr><td>Broadcom</td><td>0x42</td></tr><tr><td>Cavium</td><td>0x43</td></tr><tr><td>DigitalEquipment</td><td>0x44</td></tr><tr><td>HiSilicon</td><td>0x48</td></tr><tr><td>Infineon</td><td>0x49</td></tr><tr><td>Freescale</td><td>0x4D</td></tr><tr><td>NVIDIA</td><td>0x4E</td></tr><tr><td>APM</td><td>0x50</td></tr><tr><td>Qualcomm</td><td>0x51</td></tr><tr><td>Marvell</td><td>0x56</td></tr><tr><td>Intel</td><td>0x69</td></tr></tbody></table><h1 id="型号映射关系"><a href="#型号映射关系" class="headerlink" title="型号映射关系"></a>型号映射关系</h1><h2 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h2><table><thead><tr><th>Part ID</th><th>Model Name</th></tr></thead><tbody><tr><td>0xd03</td><td>Cortex-a53</td></tr><tr><td>0xd07</td><td>Cortex-a57</td></tr><tr><td>0xd08</td><td>Cortex-a72</td></tr></tbody></table><h2 id="Broadcom"><a href="#Broadcom" class="headerlink" title="Broadcom"></a>Broadcom</h2><table><thead><tr><th>Part ID</th><th>Model Name</th></tr></thead><tbody><tr><td>0x0f</td><td>Brahma B15</td></tr><tr><td>0x100</td><td>Brahma B53</td></tr></tbody></table><h2 id="Cavium"><a href="#Cavium" class="headerlink" title="Cavium"></a>Cavium</h2><table><thead><tr><th>Part ID</th><th>Model Name</th></tr></thead><tbody><tr><td>0x0af</td><td>Thunder X2 29xx</td></tr></tbody></table><h2 id="Qualcomm"><a href="#Qualcomm" class="headerlink" title="Qualcomm"></a>Qualcomm</h2><table><thead><tr><th>Part ID</th><th>Model Name</th></tr></thead><tbody><tr><td>0xc00</td><td>Falkor</td></tr></tbody></table><h2 id="HiSilicon"><a href="#HiSilicon" class="headerlink" title="HiSilicon"></a>HiSilicon</h2><table><thead><tr><th>Part ID</th><th>Model Name</th></tr></thead><tbody><tr><td>0xd01</td><td>Kunpeng-920</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：郑振宇&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;https://developer.arm.com/docs/ddi0595/b/aarch64-system-registers/midr_el1&quot;&gt;ARM CPU官方技术手册&lt;/a&gt;，ARM CPU的CPU型号、Vendor、版本等信息存于&lt;code&gt;MIDR_EL1&lt;/code&gt;寄存器中:&lt;br&gt;&lt;img width=&quot;492&quot; alt=&quot;MIDR&quot; src=&quot;https://user-images.githubusercontent.com/10849016/78315745-79f41080-7590-11ea-97cd-787ed68d6933.PNG&quot;&gt;&lt;br&gt;其中从低至高第0-3 bit表示&lt;code&gt;revision&lt;/code&gt;，代表固件版本的小版本号，如r1p3中的p3；&lt;br&gt;第4-15 bit表示&lt;code&gt;part number(id)&lt;/code&gt;，代表这款CPU在所在&lt;code&gt;vendor&lt;/code&gt;产品中定义的产品代码，如在&lt;code&gt;HiSilicon&lt;/code&gt;产品中，&lt;code&gt;part_id=0xd01&lt;/code&gt;代表&lt;code&gt;Kunpeng-920&lt;/code&gt;芯片；&lt;br&gt;第16-19 bit表示&lt;code&gt;architecture&lt;/code&gt;，即架构版本，&lt;code&gt;0x8&lt;/code&gt;即ARMv8；&lt;br&gt;第20-23 bit表示&lt;code&gt;variant&lt;/code&gt;，即固件版本的大版本号，如r1p3中的r1；&lt;br&gt;第24-31 bit表示&lt;code&gt;implementer&lt;/code&gt;，即&lt;code&gt;vendor id&lt;/code&gt;，如&lt;code&gt;vendor_id=0x48&lt;/code&gt;表示&lt;code&gt;HiSilicon&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux下获取ARMv8-A CPU详情的3种方法</title>
    <link href="http://yoursite.com/2020/04/03/linux-xia-huo-qu-armv8-a-cpu-xiang-qing-de-3-chong-fang-fa/"/>
    <id>http://yoursite.com/2020/04/03/linux-xia-huo-qu-armv8-a-cpu-xiang-qing-de-3-chong-fang-fa/</id>
    <published>2020-04-03T01:49:34.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>作者：郑振宇</p><p>在ARM平台上进行软件适配时，经常遇到需要根据不同CPU的具体型号、额外属性等信息进行分支处理的需求，因而需要获取CPU的详情信息；ARM架构CPU与X86架构芯片在CPU详情信息的呈现上有很大不同。本文将简述ARM CPU与CPU详情相关的知识及在Linux下获取ARMv8-A CPU详情的三种方法。</p><a id="more"></a><h1 id="ARM-CPU中有关CPU详情的寄存器"><a href="#ARM-CPU中有关CPU详情的寄存器" class="headerlink" title="ARM CPU中有关CPU详情的寄存器"></a>ARM CPU中有关CPU详情的寄存器</h1><p>根据<a href="https://developer.arm.com/docs/ddi0595/b/aarch64-system-registers/midr_el1">ARM CPU官方技术手册</a>，ARM CPU的CPU型号、Vendor、版本等信息存于<code>MIDR_EL1</code>寄存器中:<br><img width="492" alt="MIDR" src="https://user-images.githubusercontent.com/10849016/78315745-79f41080-7590-11ea-97cd-787ed68d6933.PNG"><br>其中从低至高第0-3 bit表示<code>revision</code>，代表固件版本的小版本号，如r1p3中的p3；<br>第4-15 bit表示<code>part number(id)</code>，代表这款CPU在所在<code>vendor</code>产品中定义的产品代码，如在<code>HiSilicon</code>产品中，<code>part_id=0xd01</code>代表<code>Kunpeng-920</code>芯片；<br>第16-19 bit表示<code>architecture</code>，即架构版本，<code>0x8</code>即ARMv8；<br>第20-23 bit表示<code>variant</code>，即固件版本的大版本号，如r1p3中的r1；<br>第24-31 bit表示<code>implementer</code>，即<code>vendor id</code>，如<code>vendor_id=0x48</code>表示<code>HiSilicon</code>。</p><p>想要知道一款ARM CPU的具体型号，则需要首先解析<code>vendor_id(implementer)</code> 然后再在该Vendor的所有型号中匹配<code>part_id</code>，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系</p><table><thead><tr><th align="center">Vendor Name</th><th align="center">Vendor ID</th></tr></thead><tbody><tr><td align="center">ARM</td><td align="center">0x41</td></tr><tr><td align="center">Broadcom</td><td align="center">0x42</td></tr><tr><td align="center">Cavium</td><td align="center">0x43</td></tr><tr><td align="center">DigitalEquipment</td><td align="center">0x44</td></tr><tr><td align="center">HiSilicon</td><td align="center">0x48</td></tr><tr><td align="center">Infineon</td><td align="center">0x49</td></tr><tr><td align="center">Freescale</td><td align="center">0x4D</td></tr><tr><td align="center">NVIDIA</td><td align="center">0x4E</td></tr><tr><td align="center">APM</td><td align="center">0x50</td></tr><tr><td align="center">Qualcomm</td><td align="center">0x51</td></tr><tr><td align="center">Marvell</td><td align="center">0x56</td></tr><tr><td align="center">Intel</td><td align="center">0x69</td></tr></tbody></table><p>而对于具体型号来说，对应关系则更为复杂，这里就不一一列举，可以参考<a href="https://kunpengcompute.github.io/2020/04/03/arm-cpu-vendor-ji-part-id-ying-she-guan-xi-chi-xu-geng-xin/">本站文章</a>或<a href="https://github.com/karelzak/util-linux/blob/master/sys-utils/lscpu-arm.c">util-linux/lscpu</a>工具中的相关具体实现来获取完整的映射关系，<code>lscpu</code>工具我们则将在后面的部分中进行介绍。</p><p>上面介绍过，除了CPU型号之外，我们通常还会关注CPU是否支持我们需要的特性(扩展指令集，CPU Flags, CPU features)；与X86相差较大(CPU features定义集中在EBX,ECX和EDX寄存器中)，ARM架构的这些特性分散于<a href="https://www.kernel.org/doc/Documentation/arm64/cpu-feature-registers.txt"><code>ID_PFR0_EL1</code>, <code>ID_PFR1_EL1</code>, <code>ID_DFR0_EL1</code>, <code>ID_ISAR0_EL1</code></a> 等等若干个专用寄存器中，解析起来难度较高，后面我们会详细讨论如何获取这些内容。</p><h1 id="在Linux下如何获取CPU详情信息"><a href="#在Linux下如何获取CPU详情信息" class="headerlink" title="在Linux下如何获取CPU详情信息"></a>在Linux下如何获取CPU详情信息</h1><p>在介绍具体的方法前，首先需要介绍一下ARMv8架构下的安全分层机制(Exception Level):<br><img src="https://user-images.githubusercontent.com/10849016/78317406-c9d4d680-7594-11ea-9a35-14158c262d1d.png" alt="image"><br>如上图所示，ARMv8架构是专为数据中心场景而设计的架构，相比较早的ARM架构，新增了<code>EL2</code>层用于实现硬件虚拟化；较高层的用户是无权直接限访问下一层的数据内容的，对于我们的场景来说，由上面介绍的内容中可以看到，前面所有介绍的寄存器都存在于<code>EL1</code>层，而我们通常使用的应用程序都处于<code>EL0</code>层，因此是无法直接访问到这些寄存器的。那么该如何读取这些内容呢？</p><h2 id="1-从文件节点获取"><a href="#1-从文件节点获取" class="headerlink" title="1. 从文件节点获取"></a>1. 从文件节点获取</h2><p>OS在启动时，会将底层硬件信息载入到相应的文件节点中，这样，位于<code>EL0</code>层的用户就可以通过读取这些文件节点来获取这些信息，比较常用的有两个：</p><ol><li><strong>/sys/devices/system/cpu:</strong><br>该文件夹下保存了较全的CPU信息文件，并按单个CPU进行区分，读取其中某一个的<code>regs</code>文件目录就可以获得相应的CPU详情信息，如我们尝试获取CPU0的相关信息：<br><img src="https://user-images.githubusercontent.com/10849016/78318946-9c8a2780-7598-11ea-8a31-3a76d422a055.png" alt="image"><br>可以看到，我们读取的仍然是<code>MIDR_EL1</code>寄存器相对应的信息，并且是未解析的数据，需要对应上文介绍的方法进行解析。并且目前没有在这个文件夹下找到<code>CPU Flags</code>的相关的信息，如果后续找到其所在位置，会刷新。</li><li><strong>/proc/cpuinfo:</strong><br><img src="https://user-images.githubusercontent.com/10849016/78318499-731ccc00-7597-11ea-8229-de07a2e0db92.png" alt="image"><br>通过读取cpuinfo可以看到，通过这种方法获取的CPU详情，是进行过解析的，对原始数据进行了拆分，并且是包含了<code>CPU Flag</code>信息的，但仍与X86下的结果有较大不同，各个key所对应的信息仍然需要根据表单进行解析才能转变为人为可读的信息。</li></ol><h2 id="2-使用LSCPU命令读取"><a href="#2-使用LSCPU命令读取" class="headerlink" title="2.使用LSCPU命令读取"></a>2.使用LSCPU命令读取</h2><p>Linux内核的开发者显然也发现了上文介绍的两种方法获取信息不够全面且需要二次解析的问题，因此在Linux外围工具组<code>util-linux/lscpu</code>(<a href="https://en.wikipedia.org/wiki/Util-linux">wiki</a>)中进行了改进，从<a href="https://lwn.net/Articles/749882/">2.32</a>版本开始增加了对ARM平台CPU信息的解析，从而提供人为可读的内容(由于2019年11月才合入相关Patch，HiSilicon芯片的解析需要手动编译最新主干代码才能实现)。<br><img src="https://user-images.githubusercontent.com/10849016/78319822-95fcaf80-759a-11ea-92b3-41367a2ed5da.png" alt="image"><br>从上图可以看到，<code>lscpu</code>提供了非常丰富且直观的内容。</p><h2 id="3-使用内联汇编和辅助向量直接解析"><a href="#3-使用内联汇编和辅助向量直接解析" class="headerlink" title="3.使用内联汇编和辅助向量直接解析"></a>3.使用内联汇编和辅助向量直接解析</h2><p>上文介绍的两种方法相对来说比较简单，但需要进行读取文件、运行外部命令等操作；当想在自己的程序中引用上述信息时，速度会相对较慢且会引入新的依赖(lscpu)。因此最快速的方法是通过内联汇编直接读取并解析相应的寄存器；上文中已经提到，用户在<code>EL0</code>无法直接读取到位于<code>EL1</code>的寄存器内的内容，那么该如何去做呢？</p><p>ARM已经为我们准备好了一切，用户可以通过<code>MRS</code>指令将程序状态寄存器的内容传送到通用寄存器中，再进行进一步的解析，因此我们可以这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read the cpuid data from MIDR_EL1 register */</span></span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"mrs %0, MIDR_EL1"</span> : <span class="string">"=r"</span> (cpuid));</span><br><span class="line">VIR_DEBUG(<span class="string">"CPUID read from register:  0x%016lx"</span>, cpuid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parse the coresponding part_id bits */</span></span><br><span class="line">data-&gt;pvr = cpuid&gt;&gt;<span class="number">4</span>&amp;<span class="number">0xFFF</span>;</span><br><span class="line"><span class="comment">/* parse the coresponding vendor_id bits */</span></span><br><span class="line">data-&gt;vendor_id = cpuid&gt;&gt;<span class="number">24</span>&amp;<span class="number">0xFF</span>;</span><br></pre></td></tr></table></figure><p>这样就可以快速的获取CPUID相关的具体内容，在根据表格进行映射即可获得Vendor和Model信息；</p><p>对于CPU Flags，由于牵扯到的寄存器众多，读者可以根据<a href="https://www.kernel.org/doc/Documentation/arm64/cpu-feature-registers.txt">ARM64 CPU Feature Registers</a>中的示例程序进行依次进行寄存器读取，再根据相应的映射关系进行解析，也可以使用下面将要介绍的可读性更高的另一种方法。</p><p>Linux内核提供了<a href="http://man7.org/linux/man-pages/man3/getauxval.3.html"><strong>getauxval()</strong></a>方法，用于读取辅助向量(auxiliary vector, 一个从内核到用户空间的信息交流机制)，通过读取相应的辅助向量，我们就能获取相应的硬件信息；辅助向量有很多，感兴趣的读者可以查看上面的链接，对于我们读取CPU Flags来说，关心的是<strong>AT_HWCAP</strong>这个辅助向量，通过<code>getauxval()</code>读取这个向量的值，可以获得整合过的CPU Flags信息，其bit定位规则则在<a href="https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h">hwcap.h</a>，当然，每种架构下的对应关系不相同，需要根据需要进行查找。</p><p>那么，我们就可以采用下面的方法进行解析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过移位Bit Mask来读取相应的标志位 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_SHIFTS(n)(UL(1) &lt;&lt; (n))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hwcaps = getauxval(AT_HWCAP);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* 目前ARMv8架构只有32种CPU Flags */</span></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">list</span>[<span class="number">32</span>] = &#123;<span class="string">"fp\n"</span>, <span class="string">"asimd\n"</span>, <span class="string">"evtstrm\n"</span>, <span class="string">"aes\n"</span>, <span class="string">"pmull\n"</span>, <span class="string">"sha1"</span>,</span><br><span class="line">                              <span class="string">"sha2\n"</span>, <span class="string">"crc32\n"</span>, <span class="string">"atomics\n"</span>, <span class="string">"fphp\n"</span>, <span class="string">"asimdhp\n"</span>,</span><br><span class="line">                              <span class="string">"cpuid\n"</span>, <span class="string">"asimdrdm\n"</span>,<span class="string">"jscvt\n"</span>, <span class="string">"fcma\n"</span>, <span class="string">"lrcpc\n"</span>,</span><br><span class="line">                              <span class="string">"dcpop\n"</span>, <span class="string">"sha3\n"</span>, <span class="string">"sm3\n"</span>, <span class="string">"sm4\n"</span>, <span class="string">"asimddp\n"</span> ,</span><br><span class="line">                              <span class="string">"sha512\n"</span>, <span class="string">"sve\n"</span>, <span class="string">"asimdfhm\n"</span>, <span class="string">"dit\n"</span>, <span class="string">"uscat\n"</span>,</span><br><span class="line">                              <span class="string">"ilrcpc\n"</span>, <span class="string">"flagm\n"</span>, <span class="string">"ssbs\n"</span>, <span class="string">"sb\n"</span>, <span class="string">"paca\n"</span>,<span class="string">"pacg\n"</span>,&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (hwcaps &amp; BIT_SHIFTS(i)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="built_in">list</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，可以直接通过<code>hwcap.h</code>中预先定义好的宏来做bit mask:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/hwcap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> hwcaps= getauxval(AT_HWCAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_AES)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AES instructions are available\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_CRC32)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CRC32 instructions are available\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_PMULL)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PMULL/PMULL2 instructions that operate on 64-bit data are available\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_SHA1)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SHA1 instructions are available\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hwcaps &amp; HWCAP_SHA2)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SHA2 instructions are available\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：郑振宇&lt;/p&gt;
&lt;p&gt;在ARM平台上进行软件适配时，经常遇到需要根据不同CPU的具体型号、额外属性等信息进行分支处理的需求，因而需要获取CPU的详情信息；ARM架构CPU与X86架构芯片在CPU详情信息的呈现上有很大不同。本文将简述ARM CPU与CPU详情相关的知识及在Linux下获取ARMv8-A CPU详情的三种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟化" scheme="http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="虚拟化" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Running MySQL on ARM. Does it work?</title>
    <link href="http://yoursite.com/2020/03/31/running-mysql-on-arm-does-it-work/"/>
    <id>http://yoursite.com/2020/03/31/running-mysql-on-arm-does-it-work/</id>
    <published>2020-03-31T07:11:02.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Krunal Bauskar 原文链接: <a href="https://mysqlonarm.github.io/Running-MySQL-on-ARM/">https://mysqlonarm.github.io/Running-MySQL-on-ARM/</a></p><p>I am sure most of you may have this question. In fact, I too had it before I started working on #mysqlonarm initiative. What does it take to run MySQL on ARM? Does it really work? What about dependencies? What kind of performance does it have? What about support? Is there enough community support? This could go on…..</p><p>Let’s try to answer these questions in simple question answer format.</p><a id="more"></a><h4 id="Q-Is-MySQL-supported-on-ARM"><a href="#Q-Is-MySQL-supported-on-ARM" class="headerlink" title="Q: Is MySQL supported on ARM?"></a>Q: Is MySQL supported on ARM?</h4><p>A: Yes, MySQL is officially supported on ARM. There are packages available that you can download from mysql.com site.</p><h4 id="Q-Which-OS-are-supported"><a href="#Q-Which-OS-are-supported" class="headerlink" title="Q: Which OS are supported?"></a>Q: Which OS are supported?</h4><p>A: Currently support is enabled for RHEL-7 &amp; 8/Oracle-Linux- 7 &amp; 8. I don’t see direct package support for other OS.</p><h4 id="Q-Can-we-build-it-from-source-code-for-other-OS-like-say-Ubuntu"><a href="#Q-Can-we-build-it-from-source-code-for-other-OS-like-say-Ubuntu" class="headerlink" title="Q: Can we build it from source code for other OS (like say Ubuntu)?"></a>Q: Can we build it from source code for other OS (like say Ubuntu)?</h4><p>A: Yes. It works. I have been using binaries built from source code (using mysql-8.0.19 tag current release tag) on Ubuntu-18.04 (Bionic Beaver). (Also, build it on CentOS if you want to go the source code way). This also means all needed dependencies are taken care off or are already available.</p><h4 id="Q-Are-supporting-tools-available-on-ARM"><a href="#Q-Are-supporting-tools-available-on-ARM" class="headerlink" title="Q: Are supporting tools available on ARM?"></a>Q: Are supporting tools available on ARM?</h4><p>A: Since packages are available and I was able to build it from source too the default utilities like mysql shell/mysqladmin/mysqlslap/mysqldump/etc… and tons of other things that default ships along with binaries are available. If you care about a specific tools do let me know I will check them out. For now I have tried percona-toolkit some selective tools and they too work.</p><h4 id="Q-Does-MariaDB-and-Percona-too-support-their-respective-server-flavor-on-ARM"><a href="#Q-Does-MariaDB-and-Percona-too-support-their-respective-server-flavor-on-ARM" class="headerlink" title="Q: Does MariaDB and Percona too support their respective server flavor on ARM?"></a>Q: Does MariaDB and Percona too support their respective server flavor on ARM?</h4><p>A: MariaDB Community Server packages (from MariaDB corporation) are available for ARM (CentOS7/Ubuntu-16.04/18.04). Tools for MariaDB server are not yet officially available on ARM.<br>Percona doesn’t yet officially support ARM but I was able to build it from source (MyRocks/TokuDB are not available).</p><h4 id="Q-Non-availability-of-tools-Can-that-block-my-progress-of-trying-MySQL-or-its-variants-on-ARM"><a href="#Q-Non-availability-of-tools-Can-that-block-my-progress-of-trying-MySQL-or-its-variants-on-ARM" class="headerlink" title="Q: Non-availability of tools. Can that block my progress of trying MySQL (or its variants) on ARM?"></a>Q: Non-availability of tools. Can that block my progress of trying MySQL (or its variants) on ARM?</h4><p>A: No. Since most of these tools talk mysql protocol you can of-course install them on x86 with server running on ARM. (if tool is not yet ported to ARM)</p><h4 id="Q-Is-there-enough-community-support"><a href="#Q-Is-there-enough-community-support" class="headerlink" title="Q: Is there enough community support?"></a>Q: Is there enough community support?</h4><p>A: MySQL on ARM is there for quite some time. There are active contributions from multiple vendors including ARM, Qualcomm, Huawei etc… and the community is growing rapidly. There is a lot of interest from all sections on optimizing MySQL on ARM. Lot of developers wanted to connect with this initiative. There are few challenges, most importantly non-availability of the hardware. If you are interested in contributing please talk to me (shoot me an email).</p><h4 id="Q-All-that-looks-good-What-about-performance"><a href="#Q-All-that-looks-good-What-about-performance" class="headerlink" title="Q: All that looks good. What about performance?"></a>Q: All that looks good. What about performance?</h4><p>A: This is a wide topic so I will be publishing multiple posts on this topic in the coming days but to put it in short performance is comparable. On other hand ARM instances should provide better price performance.</p><h4 id="Q-What-about-Support"><a href="#Q-What-about-Support" class="headerlink" title="Q: What about Support?"></a>Q: What about Support?</h4><p>Since packages are available officially from MySQL I presume their service offering should also cover ARM. Same with MariaDB. And of-course beyond official support there are common groups and independent developers.</p><h4 id="Command-to-build-MySQL-on-ARM"><a href="#Command-to-build-MySQL-on-ARM" class="headerlink" title="Command to build MySQL on ARM"></a>Command to build MySQL on ARM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DWITH_NUMA&#x3D;1 -DDOWNLOAD_BOOST&#x3D;1 -DWITH_BOOST&#x3D;&lt;boost-dir&gt; -DCMAKE_INSTALL_PREFIX&#x3D;&lt;dir-to-install&gt;</span><br><span class="line">make -j &lt;num-of-cores&gt;</span><br></pre></td></tr></table></figure><p>So no special flag is needed to build MySQL on ARM. (Assumes you have installed standard dependencies). It defaults compiles with “CMAKE_BUILD_TYPE=RelWithDebInfo”</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><span style="color:#4885ed">Conclusion</span></h2><p>MySQL on ARM is reality and it is now officially supported with ever growing eco-system/community. So give it a try. It could be your next cost-saving options without comprising performance or functionality.</p><p><em>If you have more questions/queries do let me know. Will try to answer them</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: Krunal Bauskar 原文链接: &lt;a href=&quot;https://mysqlonarm.github.io/Running-MySQL-on-ARM/&quot;&gt;https://mysqlonarm.github.io/Running-MySQL-on-ARM/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I am sure most of you may have this question. In fact, I too had it before I started working on #mysqlonarm initiative. What does it take to run MySQL on ARM? Does it really work? What about dependencies? What kind of performance does it have? What about support? Is there enough community support? This could go on…..&lt;/p&gt;
&lt;p&gt;Let’s try to answer these questions in simple question answer format.&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>让大数据生态在ARM架构下更顺滑</title>
    <link href="http://yoursite.com/2020/03/30/rang-da-shu-ju-sheng-tai-zai-arm-jia-gou-xia-geng-shun-hua/"/>
    <id>http://yoursite.com/2020/03/30/rang-da-shu-ju-sheng-tai-zai-arm-jia-gou-xia-geng-shun-hua/</id>
    <published>2020-03-30T12:23:45.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>作者：郑振宇</p><p>受疫情影响Linaro Connect 2020改为线上直播的Linaro Tech Days，笔者所在团队在该活动上介绍了自19年Q4以来笔者团队在各主流开源社区推广ARM生态所做的工作以及所取得的成果。直播活动约有120+与会者。</p><p>视频回放：<a href="https://static.linaro.org/connect/ltd20/videos/ltd20-104.mp4">视频连接</a><br>PPT：<a href="https://kunpengcompute.github.io/presentations/Linaro-tech-days-2020-03.pdf">LTD20-104 Make life easier for Big Data users on ARM - Our efforts and future plans</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：郑振宇&lt;/p&gt;
&lt;p&gt;受疫情影响Linaro Connect 2020改为线上直播的Linaro Tech Days，笔者所在团队在该活动上介绍了自19年Q4以来笔者团队在各主流开源社区推广ARM生态所做的工作以及所取得的成果。直播活动约有120+与会者。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="会议" scheme="http://yoursite.com/tags/%E4%BC%9A%E8%AE%AE/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Why ARM?</title>
    <link href="http://yoursite.com/2020/03/30/why-arm/"/>
    <id>http://yoursite.com/2020/03/30/why-arm/</id>
    <published>2020-03-30T10:56:54.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Krunal Bauskar 原文链接: <a href="https://mysqlonarm.github.io/Why-ARM/">https://mysqlonarm.github.io/Why-ARM/</a></p><p>ARM processors are everywhere. It is quite likely some of you may be reading this blog from an ARM powered device. Phone, IoT devices, consumer and home appliances, health-care devices, all are powered by ARM processors. ARM processors are known to be power efficient and so most of these devices that demands a long recharge cycle but less processing power started using them.</p><a id="more"></a><p>But this has changed in the past few years. More and more ARM processors are being used for high-end applications like database server, web server, application server, big data use-cases. They have already made their way to the data-centers as a server class machines. They are being looked upon as a cost effective option while running applications in cloud.</p><h2 id="ARM-ecosystem-evolution"><a href="#ARM-ecosystem-evolution" class="headerlink" title="ARM ecosystem evolution"></a><span style="color:#4885ed">ARM ecosystem evolution</span></h2><p>Few years back it was difficult to imagine that ARM would be used for running some high-end server class applications. There were 2 major reasons that I could think off:</p><ul><li>ARM were best suited for small handheld devices.</li><li>ARM ecosystem was limited around the specific product it supported.</li></ul><p>ARM ecosystem has really picked up well after some major OS providers added support for it including RedHat (CentOS), Ubuntu, Debian, Windows. This eased out porting of the major softwares to ARM. ARM community gave it a push to make sure most of the standard softwares are available on ARM viz. IDE, DB-server, Hadoop and all its variants from Apache Foundation, CI/CD software, Container, Virtualization, etc…</p><p>The ARM model that allows other vendors to license and develop their own ARM processors further helped fueled its popularity with more chip designers joining, collaborating and innovating.</p><p>Break-through came with major cloud providers like Amazon started providing ec2 instances (currently invitation only) based on ARM processors this means now everyone can boot an ARM instance and start developing/porting their software on ARM. This helped further grow the ecosystem.</p><h2 id="What-was-missing"><a href="#What-was-missing" class="headerlink" title="What was missing?"></a><span style="color:#4885ed">What was missing?</span></h2><p>Though most of these software have been ported to ARM they were not yet optimized for ARM. ARM has a weak memory model, can fit more cores in smaller space, difference in low-level instruction (for software that uses them), etc..</p><p>This was the start of the 2nd phase of ARM where the community/developer/user started moving from “running software on arm” -&gt; “optimizing software on arm”. I think this was a major win for the arm community when users started to think ARM seriously and started spending efforts on optimizing their software on ARM.</p><p>This (especially optimization) is a never ending process but I see first goal is to at-least be on par with x86. I purposely say “onpar” because each of architecture has its own USP so say if you port an enterprise class application to ARM and you can offer it to customer @ 50% of the cost (operating cost + initial investment) for 75% of the performance of x86 I think that would be still be attractive fit for most of the customers (especially given application are horizontally scalable). Of-course that doesn’t mean all applications run on ARM at reduced speed, in fact there are applications that run on ARM faster than x86 and since the optimization phase has just started in next few years a lot of applications would be running on ARM faster than other architectures.</p><h2 id="Go-Green"><a href="#Go-Green" class="headerlink" title="Go Green"></a><span style="color:#4885ed">Go Green</span></h2><p>It is everywhere and especially a matter of major concern for data-center operators (small or big). ARM being power efficient can save approximately 50% of the power compared to other architecture. This makes it help support Go-Green initiative.</p><h2 id="ARM-is-Next-Gen-processor"><a href="#ARM-is-Next-Gen-processor" class="headerlink" title="ARM is Next-Gen processor"></a><span style="color:#4885ed">ARM is Next-Gen processor</span></h2><p>It is interesting why I referred to it this way. Next generation kids are actively using kits like Andrino, Raspberry Pi, Odroid, Banana Pi, Asus tinker board, etc…. to build some of the next-gen system. These kids will be defining the next generation of computing. Given they started with ARM their social community has grown around ARM in the next few years there would be an army of ARM users/developers with a very active community.</p><p>All the groundwork and good things that are being built at this stage around ARM will be pushed to the next level once this workforce becomes active.</p><h2 id="ARM-in-Desktop-Laptop"><a href="#ARM-in-Desktop-Laptop" class="headerlink" title="ARM in Desktop/Laptop"></a><span style="color:#4885ed">ARM in Desktop/Laptop</span></h2><p>This is catching up fast and no wonder if we start seeing ARM based Desktop/PC workstation/Laptop (there are already few) commonly being used.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><span style="color:#4885ed">Conclusion</span></h2><p>The ARM Ecosystem looks a lot more fascinating and full of new challenges and opportunities. Current decade will be ruled by ARM based processors and it will be everywhere from tiny wearable devices to high-end movie experience, from auto-driving cycle/car to jumbo jet/space-craft. It is estimated that there would be 35 active ARM power devices per person. That’s Ocean of Opportunity.</p><p><em>If you have any comments feel free to drop an email (check about section)</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者: Krunal Bauskar 原文链接: &lt;a href=&quot;https://mysqlonarm.github.io/Why-ARM/&quot;&gt;https://mysqlonarm.github.io/Why-ARM/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ARM processors are everywhere. It is quite likely some of you may be reading this blog from an ARM powered device. Phone, IoT devices, consumer and home appliances, health-care devices, all are powered by ARM processors. ARM processors are known to be power efficient and so most of these devices that demands a long recharge cycle but less processing power started using them.&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>鲲鹏计算团队博客开张啦，欢迎投稿！</title>
    <link href="http://yoursite.com/2020/03/27/kun-peng-ji-suan-tuan-dui-bo-ke-kai-zhang-la-huan-ying-tou-gao/"/>
    <id>http://yoursite.com/2020/03/27/kun-peng-ji-suan-tuan-dui-bo-ke-kai-zhang-la-huan-ying-tou-gao/</id>
    <published>2020-03-27T03:37:41.000Z</published>
    <updated>2020-04-12T05:04:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>我们将在这里分享关于鲲鹏计算相关的技术、开源、生态的点滴。</p><p>欢迎关注！欢迎转发！欢迎投稿！</p><h2 id="如何投稿？"><a href="#如何投稿？" class="headerlink" title="如何投稿？"></a>如何投稿？</h2><p>非常简单，仅需要两步：</p><ol><li>点击<a href="https://github.com/kunpengcompute/kunpengcompute.github.io/issues/new">这里</a>，进入博客提交页面，我们使用Issue对博客进行管理。</li><li>填写标题和内容，issue标题即为文章标题，issue内容即为文章内容，并发布。</li></ol><p>好了，你的投稿已经完成，你会在<a href="https://github.com/kunpengcompute/kunpengcompute.github.io/issues">这里</a>看到你的投稿。</p><p>等到管理员审核通过后，会将你issue打上<code>publish</code>标签，之后，你内容就会同步在<a href="https://kunpengcompute.github.io/">博客</a>中啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们将在这里分享关于鲲鹏计算相关的技术、开源、生态的点滴。&lt;/p&gt;
&lt;p&gt;欢迎关注！欢迎转发！欢迎投稿！&lt;/p&gt;
&lt;h2 id=&quot;如何投稿？&quot;&gt;&lt;a href=&quot;#如何投稿？&quot; class=&quot;headerlink&quot; title=&quot;如何投稿？&quot;&gt;&lt;/a&gt;如何投稿？&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
