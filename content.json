{"pages":[{"title":"关于鲲鹏","text":"什么是鲲鹏计算产业？ 鲲鹏计算产业是基于Kunpeng处理器构建的全栈IT基础设施、行业应用及服务，包括PC、服务器、存储、操作系统、中间件、虚拟化、数据库、云服务、行业应用以及咨询管理服务等。 华为作为鲲鹏计算产业的成员，聚焦于发展华为鲲鹏+昇腾双引擎芯片族，通过“硬件开放、软件开源、使能合作伙伴”来推动计算产业的发展。硬件厂商基于开放的服务器主板和PC主板发展自有品牌的产品和解决方案，软件厂商基于 openEuler的开源OS以及配套的数据库、中间件等平台软件发展应用软件和服务。 鲲鹏计算产业目标是建立完善的开发者和产业人才体系，通过产业联盟、开源社区、OpenLab、行业标准组织一起完善产业链，打通行业全栈，使鲲鹏生态成为开发者和用户的首选。","link":"/about/index.html"}],"posts":[{"title":"ARM CPU Vendor 及 Part ID 映射关系（持续更新）","text":"作者：郑振宇 根据ARM CPU官方技术手册，ARM CPU的CPU型号、Vendor、版本等信息存于MIDR_EL1寄存器中:其中从低至高第0-3 bit表示revision，代表固件版本的小版本号，如r1p3中的p3；第4-15 bit表示part number(id)，代表这款CPU在所在vendor产品中定义的产品代码，如在HiSilicon产品中，part_id=0xd01代表Kunpeng-920芯片；第16-19 bit表示architecture，即架构版本，0x8即ARMv8；第20-23 bit表示variant，即固件版本的大版本号，如r1p3中的r1；第24-31 bit表示implementer，即vendor id，如vendor_id=0x48表示HiSilicon。 想要知道一款ARM CPU的具体型号，则需要首先解析vendor_id(implementer) 然后再在该Vendor的所有型号中匹配part_id，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系，以及主流厂商的主要型号映射关系： Vendor映射关系： Vendor Name Vendor ID ARM 0x41 Broadcom 0x42 Cavium 0x43 DigitalEquipment 0x44 HiSilicon 0x48 Infineon 0x49 Freescale 0x4D NVIDIA 0x4E APM 0x50 Qualcomm 0x51 Marvell 0x56 Intel 0x69 型号映射关系ARM Part ID Model Name 0xd03 Cortex-a53 0xd07 Cortex-a57 0xd08 Cortex-a72 Broadcom Part ID Model Name 0x0f Brahma B15 0x100 Brahma B53 Cavium Part ID Model Name 0x0af Thunder X2 29xx Qualcomm Part ID Model Name 0xc00 Falkor HiSilicon Part ID Model Name 0xd01 Kunpeng-920","link":"/2020/04/03/arm-cpu-vendor-ji-part-id-ying-she-guan-xi-chi-xu-geng-xin/"},{"title":"ARM优化和Java Math库有关的那些坑","text":"作者：姜逸坤 1. 起初最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例： 123456public class Hello { public static void main(String[] args) { System.out.println(\"Math.log(3): \" + Math.log(3)); System.out.println(\"StrictMath.log(3): \" + StrictMath.log(3)); }} 我们发现，在x86下，Math的结果为1.0986122886681098。 1234# on x86$ java HelloMath.log(3): 1.0986122886681098StrictMath.log(3): 1.0986122886681096 而aarch64的结果为1.0986122886681096。 1234# on aarch64$ java HelloMath.log(3): 1.0986122886681096StrictMath.log(3): 1.0986122886681096 而在Java 8的官方文档中，对此有明确说明： Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required. 因此，结论是：Math的结果有可能是不精确的，如果结果对精度有苛求，那么请使用StrictMath。 在此，我们留下2个疑问： 为什么说Math的实现不是the bit-for-bit same results？ Math是怎么实现在各个架构下better-performing implementations的？ 2. 深度探索一下Math的实现为了能够更清晰的看到StrictMath的实现，我们深入的看了下JDK的实现。 2.1 Math和StrictMath的基本实现我们从Math.log和StrictMath.log的实现为例，进行深入学习： Math.log的代码表面上很简单，就是直接调用StrictMath.log。123public static double log(double a) { return StrictMath.log(a); // default impl. delegates to StrictMath} StrictMath的代码，会调用StrictMath.c中的方法，最终会调用fdlibm的e_log.c的实现。 总体的实现和下图类似： 对于StrictMath来说，没有什么黑科技，最终的实现就是e_log.c的ieee754标准实现，是通过C语言实现的，所以在各个平台的表现是一样的，整个流程如图中蓝色部分。感兴趣的同学可以看e_log.c的源码实现即可。 2.2 Math的黑科技回到我们最初的起点，再加上一个问题： 为什么说Math的实现不是the bit-for-bit same results？ Math是怎么实现在各个架构下better-performing implementations的？ 既然Math的实现，也是直接调用StrictMath，为什么结果确不一样呢？ 原来，JVM为了让各个arch的CPU能够充分的发挥自己CPU的优势，会根据架构不同，会通过Hotspot intrinsics替换掉Math函数的实现，我们可以从代码vmSymbols.hpp看到，Math的很多实现都被替换掉了。log的替换类似于： 1do_intrinsic(_dlog, java_lang_Math, log_name, double_double_signature, F_S) 最终，Math的调用为下图红色部分： log的实现: 在x86下，最终其实调用的是assembler_x86.cpp中的flog实现:12345void Assembler::flog() { fldln2(); fxch(); fyl2x();} 而在aarch64下，我们可以从src/hotspot/cpu/目录下看到，aarch64并未实现优化版本。因此，实际aarch64调用的就是标准的StrictMath。 正因如此，x86汇编的计算结果的差异导致了x86和aarch64结果在Math.log差异。 当然，aarch64也在JDK 11中，对部分的Math接口做了加速实现，有兴趣可以看看JEP 315: Improve Aarch64 Intrinsics的实现。 3. toRadians的小插曲在ARM优化过程中，有的是因为Math库和StrictMath不同的实现造成结果不同，所以我们如果对精度要求非常高，直接切到StrictMath即可。 但有的函数，由于在Java大版本升级的过程中，出现了一些实现的差异，先看一个简单的Java程序 123456public class Hello { public static void main(String[] args) { System.out.println(\"Math.toRadians(0.33): \" + Math.toRadians(0.33)); System.out.println(\"StrictMath.toRadians(0.33): \" + StrictMath.toRadians(0.33)); }} 我们分别看看在Java11和Java8的结果： 123$ /usr/lib/jvm/java-11-openjdk-amd64/bin/java HelloMath.toRadians(0.33): 0.005759586531581287StrictMath.toRadians(0.33): 0.005759586531581287 123$ /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java HelloMath.toRadians(0.33): 0.005759586531581288StrictMath.toRadians(0.33): 0.005759586531581288 最后一位很奇怪的差了1，我们继续深入进去看到toRadians的实现： Java8的实现为：1234// Java 8 public static double toDegrees(double angrad) { return angrad * 180.0 / PI;} Java11的实现为：1234private static final double DEGREES_TO_RADIANS = 0.017453292519943295;public static double toRadians(double angdeg) { return angdeg * DEGREES_TO_RADIANS;} 原来在Java11的实现中，为了优化性能，将* 180.0 / PI提前算好了，这样每次只用乘以乘数即可，从而化简了计算。这也最终导致了，Java8和Java11在精度上有一些差别。 4. 总结 Math在各个arch下的实现不同，精度也不同，如果对精度要求很高，可以使用StrictMath。 Java不同版本的优化，也有可能导致Math库的精度不同 Math库在实现时，利用intrinsics机制，把各个arch下Math的实现换掉了，从而充分的发挥各个CPU自身的优势。","link":"/2020/04/08/arm-you-hua-he-java-math-ku-you-guan-de-na-xie-keng/"},{"title":"Linux下获取ARMv8-A CPU详情的3种方法","text":"作者：郑振宇 在ARM平台上进行软件适配时，经常遇到需要根据不同CPU的具体型号、额外属性等信息进行分支处理的需求，因而需要获取CPU的详情信息；ARM架构CPU与X86架构芯片在CPU详情信息的呈现上有很大不同。本文将简述ARM CPU与CPU详情相关的知识及在Linux下获取ARMv8-A CPU详情的三种方法。 ARM CPU中有关CPU详情的寄存器根据ARM CPU官方技术手册，ARM CPU的CPU型号、Vendor、版本等信息存于MIDR_EL1寄存器中:其中从低至高第0-3 bit表示revision，代表固件版本的小版本号，如r1p3中的p3；第4-15 bit表示part number(id)，代表这款CPU在所在vendor产品中定义的产品代码，如在HiSilicon产品中，part_id=0xd01代表Kunpeng-920芯片；第16-19 bit表示architecture，即架构版本，0x8即ARMv8；第20-23 bit表示variant，即固件版本的大版本号，如r1p3中的r1；第24-31 bit表示implementer，即vendor id，如vendor_id=0x48表示HiSilicon。 想要知道一款ARM CPU的具体型号，则需要首先解析vendor_id(implementer) 然后再在该Vendor的所有型号中匹配part_id，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系 Vendor Name Vendor ID ARM 0x41 Broadcom 0x42 Cavium 0x43 DigitalEquipment 0x44 HiSilicon 0x48 Infineon 0x49 Freescale 0x4D NVIDIA 0x4E APM 0x50 Qualcomm 0x51 Marvell 0x56 Intel 0x69 而对于具体型号来说，对应关系则更为复杂，这里就不一一列举，可以参考本站文章或util-linux/lscpu工具中的相关具体实现来获取完整的映射关系，lscpu工具我们则将在后面的部分中进行介绍。 上面介绍过，除了CPU型号之外，我们通常还会关注CPU是否支持我们需要的特性(扩展指令集，CPU Flags, CPU features)；与X86相差较大(CPU features定义集中在EBX,ECX和EDX寄存器中)，ARM架构的这些特性分散于ID_PFR0_EL1, ID_PFR1_EL1, ID_DFR0_EL1, ID_ISAR0_EL1 等等若干个专用寄存器中，解析起来难度较高，后面我们会详细讨论如何获取这些内容。 在Linux下如何获取CPU详情信息在介绍具体的方法前，首先需要介绍一下ARMv8架构下的安全分层机制(Exception Level):如上图所示，ARMv8架构是专为数据中心场景而设计的架构，相比较早的ARM架构，新增了EL2层用于实现硬件虚拟化；较高层的用户是无权直接限访问下一层的数据内容的，对于我们的场景来说，由上面介绍的内容中可以看到，前面所有介绍的寄存器都存在于EL1层，而我们通常使用的应用程序都处于EL0层，因此是无法直接访问到这些寄存器的。那么该如何读取这些内容呢？ 1. 从文件节点获取OS在启动时，会将底层硬件信息载入到相应的文件节点中，这样，位于EL0层的用户就可以通过读取这些文件节点来获取这些信息，比较常用的有两个： /sys/devices/system/cpu:该文件夹下保存了较全的CPU信息文件，并按单个CPU进行区分，读取其中某一个的regs文件目录就可以获得相应的CPU详情信息，如我们尝试获取CPU0的相关信息：可以看到，我们读取的仍然是MIDR_EL1寄存器相对应的信息，并且是未解析的数据，需要对应上文介绍的方法进行解析。并且目前没有在这个文件夹下找到CPU Flags的相关的信息，如果后续找到其所在位置，会刷新。 /proc/cpuinfo:通过读取cpuinfo可以看到，通过这种方法获取的CPU详情，是进行过解析的，对原始数据进行了拆分，并且是包含了CPU Flag信息的，但仍与X86下的结果有较大不同，各个key所对应的信息仍然需要根据表单进行解析才能转变为人为可读的信息。 2.使用LSCPU命令读取Linux内核的开发者显然也发现了上文介绍的两种方法获取信息不够全面且需要二次解析的问题，因此在Linux外围工具组util-linux/lscpu(wiki)中进行了改进，从2.32版本开始增加了对ARM平台CPU信息的解析，从而提供人为可读的内容(由于2019年11月才合入相关Patch，HiSilicon芯片的解析需要手动编译最新主干代码才能实现)。从上图可以看到，lscpu提供了非常丰富且直观的内容。 3.使用内联汇编和辅助向量直接解析上文介绍的两种方法相对来说比较简单，但需要进行读取文件、运行外部命令等操作；当想在自己的程序中引用上述信息时，速度会相对较慢且会引入新的依赖(lscpu)。因此最快速的方法是通过内联汇编直接读取并解析相应的寄存器；上文中已经提到，用户在EL0无法直接读取到位于EL1的寄存器内的内容，那么该如何去做呢？ ARM已经为我们准备好了一切，用户可以通过MRS指令将程序状态寄存器的内容传送到通用寄存器中，再进行进一步的解析，因此我们可以这样做： 12345678/* read the cpuid data from MIDR_EL1 register */asm(\"mrs %0, MIDR_EL1\" : \"=r\" (cpuid));VIR_DEBUG(\"CPUID read from register: 0x%016lx\", cpuid);/* parse the coresponding part_id bits */data-&gt;pvr = cpuid&gt;&gt;4&amp;0xFFF;/* parse the coresponding vendor_id bits */data-&gt;vendor_id = cpuid&gt;&gt;24&amp;0xFF; 这样就可以快速的获取CPUID相关的具体内容，在根据表格进行映射即可获得Vendor和Model信息； 对于CPU Flags，由于牵扯到的寄存器众多，读者可以根据ARM64 CPU Feature Registers中的示例程序进行依次进行寄存器读取，再根据相应的映射关系进行解析，也可以使用下面将要介绍的可读性更高的另一种方法。 Linux内核提供了getauxval()方法，用于读取辅助向量(auxiliary vector, 一个从内核到用户空间的信息交流机制)，通过读取相应的辅助向量，我们就能获取相应的硬件信息；辅助向量有很多，感兴趣的读者可以查看上面的链接，对于我们读取CPU Flags来说，关心的是AT_HWCAP这个辅助向量，通过getauxval()读取这个向量的值，可以获得整合过的CPU Flags信息，其bit定位规则则在hwcap.h，当然，每种架构下的对应关系不相同，需要根据需要进行查找。 那么，我们就可以采用下面的方法进行解析： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/auxv.h&gt;/* 通过移位Bit Mask来读取相应的标志位 */#define BIT_SHIFTS(n) (UL(1) &lt;&lt; (n))int main() { unsigned long hwcaps = getauxval(AT_HWCAP); int i; /* 目前ARMv8架构只有32种CPU Flags */ char *list[32] = {\"fp\\n\", \"asimd\\n\", \"evtstrm\\n\", \"aes\\n\", \"pmull\\n\", \"sha1\", \"sha2\\n\", \"crc32\\n\", \"atomics\\n\", \"fphp\\n\", \"asimdhp\\n\", \"cpuid\\n\", \"asimdrdm\\n\",\"jscvt\\n\", \"fcma\\n\", \"lrcpc\\n\", \"dcpop\\n\", \"sha3\\n\", \"sm3\\n\", \"sm4\\n\", \"asimddp\\n\" , \"sha512\\n\", \"sve\\n\", \"asimdfhm\\n\", \"dit\\n\", \"uscat\\n\", \"ilrcpc\\n\", \"flagm\\n\", \"ssbs\\n\", \"sb\\n\", \"paca\\n\",\"pacg\\n\",}; for (i = 0; i&lt; 32; i++){ if (hwcaps &amp; BIT_SHIFTS(i)) { printf(\"%s\\n\",list[i]); } }} 或者，可以直接通过hwcap.h中预先定义好的宏来做bit mask: 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;asm/hwcap.h&gt;int main(){ long hwcaps= getauxval(AT_HWCAP); if(hwcaps &amp; HWCAP_AES){ printf(\"AES instructions are available\\n\"); } if(hwcaps &amp; HWCAP_CRC32){ printf(\"CRC32 instructions are available\\n\"); } if(hwcaps &amp; HWCAP_PMULL){ printf(\"PMULL/PMULL2 instructions that operate on 64-bit data are available\\n\"); } if(hwcaps &amp; HWCAP_SHA1){ printf(\"SHA1 instructions are available\\n\"); } if(hwcaps &amp; HWCAP_SHA2){ printf(\"SHA2 instructions are available\\n\"); } return 0;}","link":"/2020/04/03/linux-xia-huo-qu-armv8-a-cpu-xiang-qing-de-3-chong-fang-fa/"},{"title":"MySQL on x86 vs ARM","text":"作者: Krunal Bauskar By and large this would be a topic of interest for most of us including me when I started to explore this space. Before we dwell into the numbers let’s first understand some basic differences between 2 architectures. Beyond being CISC and RISC let’s look at the important differences from MySQL perspective. Strong vs Weak memory model (weak memory model needs proper memory barrier while writing lock-free code). Underlying hardware specific specialized instructions. For example: both now support crc32c hardware instructions but being low-level they are different ways to invoke them. For more differences checkout for x86-SSE/ARM-ACLE. Cache Line differences. Most of the ARM processors tend to use bigger cache lines (128 bytes for all caches or a mix of 64/128 bytes). Other sys-call level differences like: absence of PAUSE instructions with ARM and substitute instruction with very low latency failing to induce needed delay, sched_getcpu is costlier on ARM introducing challenges with use of lock-free construct, memory operations seems to show higher latency, etc… Community has contributed multiple patches around this space (Topic for another blog). Since MySQL just started supporting MySQL on ARM there are few optimizations but most of the work is yet to be done. PerformanceNow let’s look at the most important aspect: Performance We tested the performance of MySQL (current release 8.0.19) on x86 and ARM. Details of the test and machine are given below. Test Setup 24 vCPU/48 GB Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz for running MySQL on x86. 24 vCPU/48 GB ARM @ 2.60GHz for running MySQL on ARM sysbench is running on a dedicated machine located in the same data-center. sysbench steps: Load Tables. (Same seed db is reused for multiple runs so warmup is needed). Checksum based warmup. Run checksum on all tables. For checksum, flow needs to fetch the rows in the buffer pool there-by causing it to warm up. Query based warm up. Can skip but helpful if you are using adaptive hash indexes. Execute TC (oltp-read-write/oltp-update-index/oltp-update-non-index/oltp-read-only/oltp-point-select) Each TC is executed for N different scalability. Given 24 vCPU tried it for 1/2/4/8/16/32/128/256. Before switching TC, an intermediate sleep is introduced to help flush changes from previous TC. This can’t ensure all changes are flushed but sleep of X secs ensures least impact on followup TC. MySQL-Server Configuration: BP is large enough to accomodate complete data in-memory For more details please check the following configuration details Details of running the scripts and automated test-script to invoke sysbench are also [available here](https://github.com/mysqlonarm/benchmark-suites) Run specific details: Table: 96-tables * 1.5 million (data-size= 34GB) Buffer Pool: 36GB Redo-Log: 4GB*2 TC-run-time: 300 secs TC-warmup: 60 (sysbench –warmup-time) workload-query-based warmup: 600 change-over-sleep: 180 checksum-based-warmup: enabled data-storage: 300GB (support for 16500 IOPS (nullify effect of Burst IOPS)). Note: Frequency Scaling (FS). Given ARM is running @ 2.6 GHz vs x86 is running @ 3.0 GHz. Comparing them directly is not fair. In order to compensate for the frequency difference, graphs also add frequency-scaled tps/qps for ARM (ARM-fscaled simply extrapolate original ARM tps/qps number by (3/2.6) factor). In real life, the factor could be a bit on the higher side given increasing CPU frequency can affect contention graphs and wait cycles. 1. Point Select: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 6696 6439 7726 4 20 2 12482 11774 14402 6 22 4 23881 21308 27555 12 29 8 45993 42110 53069 9 26 16 88517 81239 102135 9 26 32 142974 136724 164970 5 21 64 198839 212484 229430 -6 8 128 217778 241555 251282 -10 4 256 209797 224009 242073 -6 8 Analysis: ARM performs better than x86 for lower scalability but fails to scale at same rate with increasing scalability. With frequency scaling applied ARM continues to beat x86 despite of the scalability issues. 2. Read Only: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 5222 5259 6025 -1 15 2 10333 10200 11923 1 17 4 19176 19349 22126 -1 14 8 36881 37035 42555 0 15 16 70337 67065 81158 5 21 32 109207 113210 126008 -4 11 64 139294 164148 160724 -15 -2 128 151382 175872 174672 -14 -1 256 149136 164382 172080 -9 5 Analysis: ARM is almost on par with x86 for lower scalability but again fails to scale for higher scalability. With frequency scaling applied ARM continues to beat x86 (in most cases). 3. Read Write: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 137 149 158 -8 6 2 251 273 290 -8 6 4 462 502 533 -8 6 8 852 920 983 -7 7 16 1539 1678 1776 -8 6 32 2556 2906 2949 -12 1 64 3770 5158 4350 -27 -16 128 5015 8131 5787 -38 -29 256 5676 8562 6549 -34 -24 Analysis: Pattern is different with read-write workload. ARM starts lagging. Frequency scaling helps ease this lag for lower scalability but increasing scalability continues to increase the gap. 4. Update Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 623 768 719 -19 -6 4 1060 1148 1223 -8 7 8 1905 2028 2198 -6 8 16 3284 3590 3789 -9 6 32 5543 6275 6396 -12 2 64 9138 10381 10544 -12 2 128 13879 16868 16014 -18 -5 256 19954 25459 23024 -22 -10 Analysis: Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases). 5. Update Non-Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 588 686 678 -14 -1 4 1075 1118 1240 -4 11 8 1941 2043 2240 -5 10 16 3367 3662 3885 -8 6 32 5681 6438 6555 -12 2 64 9328 10631 10763 -12 1 128 14158 17245 16336 -18 -5 256 20377 26367 23512 -23 -11 Analysis: Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases). ConclusionThere are some important observations we can make: For read only workload MySQL on ARM continues to perform on-par with MySQL on x86. For write involving workload MySQL on ARM starts lagging a bit but if we consider frequency scaling things start getting better. Frequency scaling is not a real life parameter so we should consider the price-per-performance ratio. This could be a topic in itself but just a quick fact: ARM instance is 66% cheaper than x86 (24U48G same one we used). There is a pattern that we can observe. ARM workloads are very well scalable till it hits the CPU limits. With increasing scalability, contention increases and ARM starts lagging. This is expected since mutexes/contention hot-spots were all tuned for x86 (for example: spin-lock). But now that MySQL officially supports ARM and the growing ARM community and interest, it would be tuned for ARM too. To summarize, MySQL on ARM is a worth exploring option from a cost and performance perspective. If you have more questions/queries do let me know. Will try to answer them.","link":"/2020/04/08/mysql-on-x86-vs-arm/"},{"title":"Running MySQL on ARM. Does it work?","text":"作者: Krunal Bauskar 原文链接: https://mysqlonarm.github.io/Running-MySQL-on-ARM/ I am sure most of you may have this question. In fact, I too had it before I started working on #mysqlonarm initiative. What does it take to run MySQL on ARM? Does it really work? What about dependencies? What kind of performance does it have? What about support? Is there enough community support? This could go on….. Let’s try to answer these questions in simple question answer format. Q: Is MySQL supported on ARM?A: Yes, MySQL is officially supported on ARM. There are packages available that you can download from mysql.com site. Q: Which OS are supported?A: Currently support is enabled for RHEL-7 &amp; 8/Oracle-Linux- 7 &amp; 8. I don’t see direct package support for other OS. Q: Can we build it from source code for other OS (like say Ubuntu)?A: Yes. It works. I have been using binaries built from source code (using mysql-8.0.19 tag current release tag) on Ubuntu-18.04 (Bionic Beaver). (Also, build it on CentOS if you want to go the source code way). This also means all needed dependencies are taken care off or are already available. Q: Are supporting tools available on ARM?A: Since packages are available and I was able to build it from source too the default utilities like mysql shell/mysqladmin/mysqlslap/mysqldump/etc… and tons of other things that default ships along with binaries are available. If you care about a specific tools do let me know I will check them out. For now I have tried percona-toolkit some selective tools and they too work. Q: Does MariaDB and Percona too support their respective server flavor on ARM?A: MariaDB Community Server packages (from MariaDB corporation) are available for ARM (CentOS7/Ubuntu-16.04/18.04). Tools for MariaDB server are not yet officially available on ARM.Percona doesn’t yet officially support ARM but I was able to build it from source (MyRocks/TokuDB are not available). Q: Non-availability of tools. Can that block my progress of trying MySQL (or its variants) on ARM?A: No. Since most of these tools talk mysql protocol you can of-course install them on x86 with server running on ARM. (if tool is not yet ported to ARM) Q: Is there enough community support?A: MySQL on ARM is there for quite some time. There are active contributions from multiple vendors including ARM, Qualcomm, Huawei etc… and the community is growing rapidly. There is a lot of interest from all sections on optimizing MySQL on ARM. Lot of developers wanted to connect with this initiative. There are few challenges, most importantly non-availability of the hardware. If you are interested in contributing please talk to me (shoot me an email). Q: All that looks good. What about performance?A: This is a wide topic so I will be publishing multiple posts on this topic in the coming days but to put it in short performance is comparable. On other hand ARM instances should provide better price performance. Q: What about Support?Since packages are available officially from MySQL I presume their service offering should also cover ARM. Same with MariaDB. And of-course beyond official support there are common groups and independent developers. Command to build MySQL on ARM12cmake .. -DWITH_NUMA=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=&lt;boost-dir&gt; -DCMAKE_INSTALL_PREFIX=&lt;dir-to-install&gt;make -j &lt;num-of-cores&gt; So no special flag is needed to build MySQL on ARM. (Assumes you have installed standard dependencies). It defaults compiles with “CMAKE_BUILD_TYPE=RelWithDebInfo” ConclusionMySQL on ARM is reality and it is now officially supported with ever growing eco-system/community. So give it a try. It could be your next cost-saving options without comprising performance or functionality. If you have more questions/queries do let me know. Will try to answer them","link":"/2020/03/31/running-mysql-on-arm-does-it-work/"},{"title":"Web开源服务之ARM64现状","text":"作者: 王玺源 社区核心参与者：Martin Grigorov、Michael Rumph 背景开源界中Web服务众多,但其中很多软件对ARM64的支持并不理想。或是没有官方CI测试保证代码质量，或是在ARM64上的性能明显差于X86_64，甚至有的服务根本无法在ARM上运行。为了完善Web领域的ARM64生态，我们参与了主流的几个开源社区，旨在推动Web on ARM64。以下是我们近期的一些进展，以供大家参考。 概述我们目前参与了主流的共9个Web相关项目。如下所示 项目 主要语言 Apache Httpd Server C Apache Tomcat Java Memcached C Nginx C Lighttpd C JBoss/WildFly Java HAProxy C Squid C++ Varnish Cache C 针对这些项目，我们按照以下三个方面循序渐进的推动中: 能不能在ARM上运行 如何稳定在ARM上运行 怎么更好的在ARM上运行 能不能在ARM上运行我们可以看到这9大项目主要由Java和C/C++编写。 首先，像Python、Java这种自带runtime的语言天生就是跨平台的。这样的项目在ARM64平台上至少可以保证程序的可运行。 而C/C++项目则需要先编译成ARM64平台的目标可执行文件。这样的项目则需要先进行编译测试。 经过我们的测试，这9个Web项目都可以在ARM64上成功编译并运行。 如何稳定在ARM上运行所谓稳定，包含两个方面： 软件在ARM64上是否和在X86_64上行为一致？ 随着代码更新迭代，软件在ARM64上是否持续可用？ 行为一致我们常遇到两类行为一致的问题： 同样的代码，不同的结果 同样的功能，不同的支持 很遗憾，由于架构不同、底层实现不同等原因，很多软件的某些行为在X86_64和ARM64上的行为并不一致。 例如，之前的文章提到的Java中Math计算结果的差异。 又或者某些功能依赖独有的平台特性或者特殊的第三方库，导致在X86_64上可以运行的功能，在ARM64上却执行失败。 例如我们发现WildFly官方发布的源码包中缺少了个别ARM64平台的.so文件，这就导致个别调用.so的功能不可用。 针对这种问题，我们需要打开代码逐个分析、逐个修复。保证所有测试在ARM64上全部通过。 持续可用CI/CD是保证软件持续可用的重要方法。主流软件的CI系统都有X86_64平台的测试。而ARM64平台的少之又少。 针对这个问题，我们推动了这9个项目的ARM CI支持。除Lighttpd还在推动中以外，其他8个项目目前都已支持了ARM CI。甚至其中4个项目已经官方声明了ARM64的支持（详见附录）。 其中Httpd、Tomcat、Memcached、HAProxy和Varnish Cache通过Travis CI支持了ARM64测试。Nginx使用内部CI，对外不可见。Squid使用自己的树莓派。而JBOSS使用了我们捐献的基于Kunpeng 920的ARM虚拟机。同时我们也计划捐献同样的测试机到Lighttpd社区中。 随着ARM CI的落地，我们将持续保证ARM CI的稳定。我们相信在不久的将来，这9大核心Web项目都会官方声明ARM64的支持，并满足用户在ARM64上稳定、高效使用Web服务的需求。 怎么更好的在ARM上运行我们不仅希望软件在ARM64上能用，还在不断探索如何让软件在ARM64上用的好。其中性能优化是重中之重，也是我们未来一段时间的主要投入点。 例如，有些软件只实现了X86_64的汇编实现，但缺少ARM64的汇编代码。 又或者有些在X86_64上纯软实现的功能，可以在ARM64上通过下沉至硬编码的方式提高性能。 甚至还可以考虑如何最大化利用ARM64的多核优势，或规避ARM64的锁劣势等等。 关于性能优化的内容，我们将在以后的文章中针对不同的软件一一细说。敬请期待。 附录最后附上我们参与Web社区的总览表格及相关链接，感兴趣的同学可以进一步详读，有任何问题，欢迎留言。 Official arm64 CI CI tool Package in Downloads Official ARM support Apache Tomcat YES TravisCI Binary WIP(work in progress) Memcached YES 1. BuildBot 2. TravisCI Source Code YES Apache httpd YES TravisCI Source Code YES NGINX YES Internal Only for Ubuntu LTSs YES Lighttpd NO Jenkins Source Code NO JBoss/Wildfly YES TeamCity Source Code NO HAProxy YES 1. CirrusCI 2. TravisCI Source Code YES Squid YES Jenkins Source Code NO Varnish Cache YES Travis 1. Source Code 2. Package NO","link":"/2020/04/10/web-kai-yuan-fu-wu-zhi-arm64-xian-zhuang/"},{"title":"Why ARM?","text":"作者: Krunal Bauskar 原文链接: https://mysqlonarm.github.io/Why-ARM/ ARM processors are everywhere. It is quite likely some of you may be reading this blog from an ARM powered device. Phone, IoT devices, consumer and home appliances, health-care devices, all are powered by ARM processors. ARM processors are known to be power efficient and so most of these devices that demands a long recharge cycle but less processing power started using them. But this has changed in the past few years. More and more ARM processors are being used for high-end applications like database server, web server, application server, big data use-cases. They have already made their way to the data-centers as a server class machines. They are being looked upon as a cost effective option while running applications in cloud. ARM ecosystem evolutionFew years back it was difficult to imagine that ARM would be used for running some high-end server class applications. There were 2 major reasons that I could think off: ARM were best suited for small handheld devices. ARM ecosystem was limited around the specific product it supported. ARM ecosystem has really picked up well after some major OS providers added support for it including RedHat (CentOS), Ubuntu, Debian, Windows. This eased out porting of the major softwares to ARM. ARM community gave it a push to make sure most of the standard softwares are available on ARM viz. IDE, DB-server, Hadoop and all its variants from Apache Foundation, CI/CD software, Container, Virtualization, etc… The ARM model that allows other vendors to license and develop their own ARM processors further helped fueled its popularity with more chip designers joining, collaborating and innovating. Break-through came with major cloud providers like Amazon started providing ec2 instances (currently invitation only) based on ARM processors this means now everyone can boot an ARM instance and start developing/porting their software on ARM. This helped further grow the ecosystem. What was missing?Though most of these software have been ported to ARM they were not yet optimized for ARM. ARM has a weak memory model, can fit more cores in smaller space, difference in low-level instruction (for software that uses them), etc.. This was the start of the 2nd phase of ARM where the community/developer/user started moving from “running software on arm” -&gt; “optimizing software on arm”. I think this was a major win for the arm community when users started to think ARM seriously and started spending efforts on optimizing their software on ARM. This (especially optimization) is a never ending process but I see first goal is to at-least be on par with x86. I purposely say “onpar” because each of architecture has its own USP so say if you port an enterprise class application to ARM and you can offer it to customer @ 50% of the cost (operating cost + initial investment) for 75% of the performance of x86 I think that would be still be attractive fit for most of the customers (especially given application are horizontally scalable). Of-course that doesn’t mean all applications run on ARM at reduced speed, in fact there are applications that run on ARM faster than x86 and since the optimization phase has just started in next few years a lot of applications would be running on ARM faster than other architectures. Go GreenIt is everywhere and especially a matter of major concern for data-center operators (small or big). ARM being power efficient can save approximately 50% of the power compared to other architecture. This makes it help support Go-Green initiative. ARM is Next-Gen processorIt is interesting why I referred to it this way. Next generation kids are actively using kits like Andrino, Raspberry Pi, Odroid, Banana Pi, Asus tinker board, etc…. to build some of the next-gen system. These kids will be defining the next generation of computing. Given they started with ARM their social community has grown around ARM in the next few years there would be an army of ARM users/developers with a very active community. All the groundwork and good things that are being built at this stage around ARM will be pushed to the next level once this workforce becomes active. ARM in Desktop/LaptopThis is catching up fast and no wonder if we start seeing ARM based Desktop/PC workstation/Laptop (there are already few) commonly being used. ConclusionThe ARM Ecosystem looks a lot more fascinating and full of new challenges and opportunities. Current decade will be ruled by ARM based processors and it will be everywhere from tiny wearable devices to high-end movie experience, from auto-driving cycle/car to jumbo jet/space-craft. It is estimated that there would be 35 active ARM power devices per person. That’s Ocean of Opportunity. If you have any comments feel free to drop an email (check about section)","link":"/2020/03/30/why-arm/"},{"title":"让大数据生态在ARM架构下更顺滑","text":"作者：郑振宇 受疫情影响Linaro Connect 2020改为线上直播的Linaro Tech Days，笔者所在团队在该活动上介绍了自19年Q4以来笔者团队在各主流开源社区推广ARM生态所做的工作以及所取得的成果。直播活动约有120+与会者。 视频回放：视频连接PPT：LTD20-104 Make life easier for Big Data users on ARM - Our efforts and future plans","link":"/2020/03/30/rang-da-shu-ju-sheng-tai-zai-arm-jia-gou-xia-geng-shun-hua/"},{"title":"鲲鹏计算团队博客开张啦，欢迎投稿！","text":"我们将在这里分享关于鲲鹏计算相关的技术、开源、生态的点滴。 欢迎关注！欢迎转发！欢迎投稿！ 如何投稿？非常简单，仅需要两步： 点击这里，进入博客提交页面，我们使用Issue对博客进行管理。 填写标题和内容，issue标题即为文章标题，issue内容即为文章内容，并发布。 好了，你的投稿已经完成，你会在这里看到你的投稿。 等到管理员审核通过后，会将你issue打上publish标签，之后，你内容就会同步在博客中啦！","link":"/2020/03/27/kun-peng-ji-suan-tuan-dui-bo-ke-kai-zhang-la-huan-ying-tou-gao/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","link":"/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"基础库","slug":"基础库","link":"/tags/%E5%9F%BA%E7%A1%80%E5%BA%93/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"会议","slug":"会议","link":"/tags/%E4%BC%9A%E8%AE%AE/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"categories":[{"name":"虚拟化","slug":"虚拟化","link":"/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"基础库","slug":"基础库","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BA%93/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}